/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var bundle;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./grammar/eberban.js":
/*!****************************!*\
  !*** ./grammar/eberban.js ***!
  \****************************/
/***/ ((module) => {

eval("var camxes = (function() {\n  /*\n   * Generated by PEG.js 0.8.0.\n   *\n   * http://pegjs.majda.cz/\n   */\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function SyntaxError(message, expected, found, offset, line, column) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.offset   = offset;\n    this.line     = line;\n    this.column   = column;\n\n    this.name     = \"SyntaxError\";\n  }\n\n  peg$subclass(SyntaxError, Error);\n\n  function parse(input) {\n    var options = arguments.length > 1 ? arguments[1] : {},\n\n        peg$FAILED = {},\n\n        peg$startRuleFunctions = { text: peg$parsetext },\n        peg$startRuleFunction  = peg$parsetext,\n\n        peg$c0 = peg$FAILED,\n        peg$c1 = [],\n        peg$c2 = null,\n        peg$c3 = function(expr) {return _node(\"text\", expr);},\n        peg$c4 = void 0,\n        peg$c5 = function(expr) {return _node(\"paragraphs\", expr);},\n        peg$c6 = function(expr) {return _node(\"paragraph\", expr);},\n        peg$c7 = function(expr) {return _node(\"paragraph_unit\", expr);},\n        peg$c8 = function(expr) {return _node(\"arguments_list\", expr);},\n        peg$c9 = function(expr) {return _node(\"definition\", expr);},\n        peg$c10 = function(expr) {return _node(\"definition_key\", expr);},\n        peg$c11 = function(expr) {return _node(\"sentence\", expr);},\n        peg$c12 = function(expr) {return _node(\"scope\", expr);},\n        peg$c13 = function(expr) {return _node(\"scope_1\", expr);},\n        peg$c14 = function(expr) {return _node(\"scope_list\", expr);},\n        peg$c15 = function(expr) {return _node(\"scope_list_element\", expr);},\n        peg$c16 = function(expr) {return _node(\"scope_2\", expr);},\n        peg$c17 = function(expr) {return _node(\"chaining\", expr);},\n        peg$c18 = function(expr) {return _node(\"chaining_neg\", expr);},\n        peg$c19 = function(expr) {return _node(\"chaining_unit\", expr);},\n        peg$c20 = function(expr) {return _node(\"va_scope\", expr);},\n        peg$c21 = function(expr) {return _node(\"va_scope_first\", expr);},\n        peg$c22 = function(expr) {return _node(\"va_scope_next\", expr);},\n        peg$c23 = function(expr) {return _node(\"predicate\", expr);},\n        peg$c24 = function(expr) {return _node(\"predicate_1\", expr);},\n        peg$c25 = function(expr) {return _node(\"predicate_root\", expr);},\n        peg$c26 = function(expr) {return _node(\"predicate_number\", expr);},\n        peg$c27 = function(expr) {return _node(\"predicate_compound\", expr);},\n        peg$c28 = function(expr) {return _node(\"predicate_borrowing\", expr);},\n        peg$c29 = function(expr) {return _node(\"predicate_scope\", expr);},\n        peg$c30 = function(expr) {return _node(\"predicate_quote\", expr);},\n        peg$c31 = function(expr) {return _node(\"grammatical_quote\", expr);},\n        peg$c32 = function(expr) {return _node(\"one_word_quote\", expr);},\n        peg$c33 = function(expr) {return _node(\"foreign_quote\", expr);},\n        peg$c34 = function(expr) {return _node(\"foreign_quote_content\", expr);},\n        peg$c35 = function(expr) {return _node(\"number\", expr);},\n        peg$c36 = function(expr) {return _node(\"borrowing_group\", expr);},\n        peg$c37 = function(expr) {return _node(\"predicate_simple\", expr);},\n        peg$c38 = function(expr) {return _node(\"predicate_variable\", expr);},\n        peg$c39 = function(expr) {return _node(\"free_prefix\", expr);},\n        peg$c40 = function(expr) {return _node(\"free_post\", expr);},\n        peg$c41 = function(expr) {return _node(\"free_subscript\", expr);},\n        peg$c42 = function(expr) {return _node(\"free_parenthetical\", expr);},\n        peg$c43 = function(expr) {return _node(\"override\", expr);},\n        peg$c44 = function(expr) {return _node(\"override_word\", expr);},\n        peg$c45 = function(expr) {return _node(\"BA_clause\", expr);},\n        peg$c46 = function(expr) {return _node(\"BE_clause\", expr);},\n        peg$c47 = function(expr) {return _node(\"BI_clause\", expr);},\n        peg$c48 = function(expr) {return _node(\"BO_clause\", expr);},\n        peg$c49 = function(expr) {return _node(\"BU_clause\", expr);},\n        peg$c50 = function(expr) {return _node(\"DA_clause\", expr);},\n        peg$c51 = function(expr) {return _node(\"DI_clause\", expr);},\n        peg$c52 = function(expr) {return _node(\"DO_clause\", expr);},\n        peg$c53 = function(expr) {return _node(\"DOI_clause\", expr);},\n        peg$c54 = function(expr) {return _node(\"DU_clause\", expr);},\n        peg$c55 = function(expr) {return _node(\"SA_clause\", expr);},\n        peg$c56 = function(expr) {return _node(\"ZA_clause\", expr);},\n        peg$c57 = function(expr) {return _node(\"VA_clause\", expr);},\n        peg$c58 = function(expr) {return _node(\"FA_clause\", expr);},\n        peg$c59 = function(expr) {return _node(\"VAI_clause\", expr);},\n        peg$c60 = function(expr) {return _node(\"GA_clause\", expr);},\n        peg$c61 = function(expr) {return _node(\"KA_clause\", expr);},\n        peg$c62 = function(expr) {return _node(\"MA_clause\", expr);},\n        peg$c63 = function(expr) {return _node(\"PA_clause\", expr);},\n        peg$c64 = function(expr) {return _node(\"PAI_clause\", expr);},\n        peg$c65 = function(expr) {return _node(\"PE_clause\", expr);},\n        peg$c66 = function(expr) {return _node(\"PEI_clause\", expr);},\n        peg$c67 = function(expr) {return _node(\"PI_clause\", expr);},\n        peg$c68 = function(expr) {return _node(\"PO_clause\", expr);},\n        peg$c69 = function(expr) {return _node(\"POI_clause\", expr);},\n        peg$c70 = function(expr) {return _node(\"PU_clause\", expr);},\n        peg$c71 = function(expr) {return _node(\"TA_clause\", expr);},\n        peg$c72 = function(expr) {return _node(\"LA_clause\", expr);},\n        peg$c73 = function(expr) {return _node(\"LAI_clause\", expr);},\n        peg$c74 = function(expr) {return _node(\"LE_clause\", expr);},\n        peg$c75 = function(expr) {return _node(\"LO_clause\", expr);},\n        peg$c76 = function(expr) {return (expr == \"\" || !expr) ? [\"BE\"] : _node_empty(\"BE_clause_elidible\", expr);},\n        peg$c77 = function(expr) {return (expr == \"\" || !expr) ? [\"PA\"] : _node_empty(\"PA_clause_elidible\", expr);},\n        peg$c78 = function(expr) {return (expr == \"\" || !expr) ? [\"PAI\"] : _node_empty(\"PAI_clause_elidible\", expr);},\n        peg$c79 = function(expr) {return (expr == \"\" || !expr) ? [\"PEI\"] : _node_empty(\"PEI_clause_elidible\", expr);},\n        peg$c80 = function(expr) {return (expr == \"\" || !expr) ? [\"POI\"] : _node_empty(\"POI_clause_elidible\", expr);},\n        peg$c81 = function(expr) {return (expr == \"\" || !expr) ? [\"VAI\"] : _node_empty(\"VAI_clause_elidible\", expr);},\n        peg$c82 = function(expr) {return _node(\"BA\", expr);},\n        peg$c83 = function(expr) {return _node(\"BE\", expr);},\n        peg$c84 = function(expr) {return _node(\"BI\", expr);},\n        peg$c85 = function(expr) {return _node(\"BO\", expr);},\n        peg$c86 = function(expr) {return _node(\"BU\", expr);},\n        peg$c87 = function(expr) {return _node(\"CA\", expr);},\n        peg$c88 = function(expr) {return _node(\"DA\", expr);},\n        peg$c89 = function(expr) {return _node(\"DI\", expr);},\n        peg$c90 = function(expr) {return _node(\"DO\", expr);},\n        peg$c91 = function(expr) {return _node(\"DOI\", expr);},\n        peg$c92 = function(expr) {return _node(\"DU\", expr);},\n        peg$c93 = function(expr) {return _node(\"FA\", expr);},\n        peg$c94 = function(expr) {return _node(\"GA\", expr);},\n        peg$c95 = function(expr) {return _node(\"KA\", expr);},\n        peg$c96 = function(expr) {return _node(\"MA\", expr);},\n        peg$c97 = function(expr) {return _node(\"PA\", expr);},\n        peg$c98 = function(expr) {return _node(\"PAI\", expr);},\n        peg$c99 = function(expr) {return _node(\"PE\", expr);},\n        peg$c100 = function(expr) {return _node(\"PEI\", expr);},\n        peg$c101 = function(expr) {return _node(\"PI\", expr);},\n        peg$c102 = function(expr) {return _node(\"PO\", expr);},\n        peg$c103 = function(expr) {return _node(\"POI\", expr);},\n        peg$c104 = function(expr) {return _node(\"PU\", expr);},\n        peg$c105 = function(expr) {return _node(\"SA\", expr);},\n        peg$c106 = function(expr) {return _node(\"TA\", expr);},\n        peg$c107 = function(expr) {return _node(\"VA\", expr);},\n        peg$c108 = function(expr) {return _node(\"VAI\", expr);},\n        peg$c109 = function(expr) {return _node(\"LA\", expr);},\n        peg$c110 = function(expr) {return _node(\"LAI\", expr);},\n        peg$c111 = function(expr) {return _node(\"LE\", expr);},\n        peg$c112 = function(expr) {return _node(\"LO\", expr);},\n        peg$c113 = function(expr) {return _node(\"ZA\", expr);},\n        peg$c114 = function(expr) { _assign_foreign_quote_delim(expr); return _node(\"foreign_quote_open\", expr); },\n        peg$c115 = { type: \"any\", description: \"any character\" },\n        peg$c116 = function(expr) { return _is_foreign_quote_delim(expr); },\n        peg$c117 = function(expr) { return [\"foreign_quote_word\", join_expr(expr)]; },\n        peg$c118 = function(expr) { return _node(\"foreign_quote_close\", expr); },\n        peg$c119 = function(expr) {return _node(\"compound\", expr);},\n        peg$c120 = function(expr) {return _node(\"compound_2\", expr);},\n        peg$c121 = function(expr) {return _node(\"compound_3\", expr);},\n        peg$c122 = function(expr) {return _node(\"compound_4\", expr);},\n        peg$c123 = function(expr) {return _node(\"compound_n\", expr);},\n        peg$c124 = function(expr) {return _node(\"compound_n_end\", expr);},\n        peg$c125 = function(expr) {return _node(\"compound_word\", expr);},\n        peg$c126 = function(expr) {return _node(\"borrowing\", expr);},\n        peg$c127 = function(expr) {return _node(\"borrowing_content\", expr);},\n        peg$c128 = function(expr) {return _node(\"borrowing_end\", expr);},\n        peg$c129 = function(expr) {return _node(\"foreign_word\", expr);},\n        peg$c130 = function(expr) {return _node(\"native_word\", expr);},\n        peg$c131 = function(expr) {return _node(\"particle\", expr);},\n        peg$c132 = function(expr) {return _node(\"root\", expr);},\n        peg$c133 = function(expr) {return _node(\"particle_1\", expr);},\n        peg$c134 = function(expr) {return _node(\"root_1\", expr);},\n        peg$c135 = function(expr) {return _node(\"root_2\", expr);},\n        peg$c136 = function(expr) {return _node(\"root_3\", expr);},\n        peg$c137 = function(expr) {return _node(\"haeiou\", expr);},\n        peg$c138 = function(expr) {return _node(\"aeiou\", expr);},\n        peg$c139 = function(expr) {return _node(\"consonant_cluster\", expr);},\n        peg$c140 = function(expr) {return _node(\"initial_consonant_pair\", expr);},\n        peg$c141 = function(expr) {return _node(\"initial\", expr);},\n        peg$c142 = function(expr) {return _node(\"plosib\", expr);},\n        peg$c143 = function(expr) {return _node(\"consonant\", expr);},\n        peg$c144 = function(expr) {return _node(\"liquid\", expr);},\n        peg$c145 = function(expr) {return _node(\"other\", expr);},\n        peg$c146 = function(expr) {return _node(\"plosive\", expr);},\n        peg$c147 = function(expr) {return _node(\"sibilant\", expr);},\n        peg$c148 = function(expr) {return _node(\"sonorant\", expr);},\n        peg$c149 = function(expr) {return _node(\"voiced\", expr);},\n        peg$c150 = function(expr) {return _node(\"unvoiced\", expr);},\n        peg$c151 = /^[aA]/,\n        peg$c152 = { type: \"class\", value: \"[aA]\", description: \"[aA]\" },\n        peg$c153 = function(expr) {return [\"a\", \"a\"];},\n        peg$c154 = /^[eE]/,\n        peg$c155 = { type: \"class\", value: \"[eE]\", description: \"[eE]\" },\n        peg$c156 = function(expr) {return [\"e\", \"e\"];},\n        peg$c157 = /^[iI]/,\n        peg$c158 = { type: \"class\", value: \"[iI]\", description: \"[iI]\" },\n        peg$c159 = function(expr) {return [\"i\", \"i\"];},\n        peg$c160 = /^[oO]/,\n        peg$c161 = { type: \"class\", value: \"[oO]\", description: \"[oO]\" },\n        peg$c162 = function(expr) {return [\"o\", \"o\"];},\n        peg$c163 = /^[uU]/,\n        peg$c164 = { type: \"class\", value: \"[uU]\", description: \"[uU]\" },\n        peg$c165 = function(expr) {return [\"u\", \"u\"];},\n        peg$c166 = /^[hH]/,\n        peg$c167 = { type: \"class\", value: \"[hH]\", description: \"[hH]\" },\n        peg$c168 = function(expr) {return [\"h\", \"h\"];},\n        peg$c169 = /^[nN]/,\n        peg$c170 = { type: \"class\", value: \"[nN]\", description: \"[nN]\" },\n        peg$c171 = function(expr) {return [\"n\", \"n\"];},\n        peg$c172 = /^[rR]/,\n        peg$c173 = { type: \"class\", value: \"[rR]\", description: \"[rR]\" },\n        peg$c174 = function(expr) {return [\"r\", \"r\"];},\n        peg$c175 = /^[bB]/,\n        peg$c176 = { type: \"class\", value: \"[bB]\", description: \"[bB]\" },\n        peg$c177 = function(expr) {return [\"b\", \"b\"];},\n        peg$c178 = /^[dD]/,\n        peg$c179 = { type: \"class\", value: \"[dD]\", description: \"[dD]\" },\n        peg$c180 = function(expr) {return [\"d\", \"d\"];},\n        peg$c181 = /^[gG]/,\n        peg$c182 = { type: \"class\", value: \"[gG]\", description: \"[gG]\" },\n        peg$c183 = function(expr) {return [\"g\", \"g\"];},\n        peg$c184 = /^[vV]/,\n        peg$c185 = { type: \"class\", value: \"[vV]\", description: \"[vV]\" },\n        peg$c186 = function(expr) {return [\"v\", \"v\"];},\n        peg$c187 = /^[jJ]/,\n        peg$c188 = { type: \"class\", value: \"[jJ]\", description: \"[jJ]\" },\n        peg$c189 = function(expr) {return [\"j\", \"j\"];},\n        peg$c190 = /^[zZ]/,\n        peg$c191 = { type: \"class\", value: \"[zZ]\", description: \"[zZ]\" },\n        peg$c192 = function(expr) {return [\"z\", \"z\"];},\n        peg$c193 = /^[sS]/,\n        peg$c194 = { type: \"class\", value: \"[sS]\", description: \"[sS]\" },\n        peg$c195 = function(expr) {return [\"s\", \"s\"];},\n        peg$c196 = /^[cC]/,\n        peg$c197 = { type: \"class\", value: \"[cC]\", description: \"[cC]\" },\n        peg$c198 = function(expr) {return [\"c\", \"c\"];},\n        peg$c199 = /^[kK]/,\n        peg$c200 = { type: \"class\", value: \"[kK]\", description: \"[kK]\" },\n        peg$c201 = function(expr) {return [\"k\", \"k\"];},\n        peg$c202 = /^[fF]/,\n        peg$c203 = { type: \"class\", value: \"[fF]\", description: \"[fF]\" },\n        peg$c204 = function(expr) {return [\"f\", \"f\"];},\n        peg$c205 = /^[pP]/,\n        peg$c206 = { type: \"class\", value: \"[pP]\", description: \"[pP]\" },\n        peg$c207 = function(expr) {return [\"p\", \"p\"];},\n        peg$c208 = /^[tT]/,\n        peg$c209 = { type: \"class\", value: \"[tT]\", description: \"[tT]\" },\n        peg$c210 = function(expr) {return [\"t\", \"t\"];},\n        peg$c211 = /^[mM]/,\n        peg$c212 = { type: \"class\", value: \"[mM]\", description: \"[mM]\" },\n        peg$c213 = function(expr) {return [\"m\", \"m\"];},\n        peg$c214 = /^[lL]/,\n        peg$c215 = { type: \"class\", value: \"[lL]\", description: \"[lL]\" },\n        peg$c216 = function(expr) {return [\"l\", \"l\"];},\n        peg$c217 = function(expr) {return _node(\"post_word\", expr);},\n        peg$c218 = function(expr) {return _node(\"spaces\", expr);},\n        peg$c219 = /^['.]/,\n        peg$c220 = { type: \"class\", value: \"['.]\", description: \"['.]\" },\n        peg$c221 = function(expr) {return _node(\"pause_char\", expr);},\n        peg$c222 = /^[\\t\\n\\r?! ]/,\n        peg$c223 = { type: \"class\", value: \"[\\\\t\\\\n\\\\r?! ]\", description: \"[\\\\t\\\\n\\\\r?! ]\" },\n        peg$c224 = function(expr) {return _join(expr);},\n        peg$c225 = /^[.0123456789]/,\n        peg$c226 = { type: \"class\", value: \"[.0123456789]\", description: \"[.0123456789]\" },\n        peg$c227 = function(expr) {return [\"digit\", expr];},\n        peg$c228 = function(expr) {return _node(\"EOF\", expr);},\n\n        peg$currPos          = 0,\n        peg$reportedPos      = 0,\n        peg$cachedPos        = 0,\n        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$cache = {},\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$reportedPos, peg$currPos);\n    }\n\n    function offset() {\n      return peg$reportedPos;\n    }\n\n    function line() {\n      return peg$computePosDetails(peg$reportedPos).line;\n    }\n\n    function column() {\n      return peg$computePosDetails(peg$reportedPos).column;\n    }\n\n    function expected(description) {\n      throw peg$buildException(\n        null,\n        [{ type: \"other\", description: description }],\n        peg$reportedPos\n      );\n    }\n\n    function error(message) {\n      throw peg$buildException(message, null, peg$reportedPos);\n    }\n\n    function peg$computePosDetails(pos) {\n      function advance(details, startPos, endPos) {\n        var p, ch;\n\n        for (p = startPos; p < endPos; p++) {\n          ch = input.charAt(p);\n          if (ch === \"\\n\") {\n            if (!details.seenCR) { details.line++; }\n            details.column = 1;\n            details.seenCR = false;\n          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n            details.line++;\n            details.column = 1;\n            details.seenCR = true;\n          } else {\n            details.column++;\n            details.seenCR = false;\n          }\n        }\n      }\n\n      if (peg$cachedPos !== pos) {\n        if (peg$cachedPos > pos) {\n          peg$cachedPos = 0;\n          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n        }\n        advance(peg$cachedPosDetails, peg$cachedPos, pos);\n        peg$cachedPos = pos;\n      }\n\n      return peg$cachedPosDetails;\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildException(message, expected, pos) {\n      function cleanupExpected(expected) {\n        var i = 1;\n\n        expected.sort(function(a, b) {\n          if (a.description < b.description) {\n            return -1;\n          } else if (a.description > b.description) {\n            return 1;\n          } else {\n            return 0;\n          }\n        });\n\n        while (i < expected.length) {\n          if (expected[i - 1] === expected[i]) {\n            expected.splice(i, 1);\n          } else {\n            i++;\n          }\n        }\n      }\n\n      function buildMessage(expected, found) {\n        function stringEscape(s) {\n          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n          return s\n            .replace(/\\\\/g,   '\\\\\\\\')\n            .replace(/\"/g,    '\\\\\"')\n            .replace(/\\x08/g, '\\\\b')\n            .replace(/\\t/g,   '\\\\t')\n            .replace(/\\n/g,   '\\\\n')\n            .replace(/\\f/g,   '\\\\f')\n            .replace(/\\r/g,   '\\\\r')\n            .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n            .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n            .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n            .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n        }\n\n        var expectedDescs = new Array(expected.length),\n            expectedDesc, foundDesc, i;\n\n        for (i = 0; i < expected.length; i++) {\n          expectedDescs[i] = expected[i].description;\n        }\n\n        expectedDesc = expected.length > 1\n          ? expectedDescs.slice(0, -1).join(\", \")\n              + \" or \"\n              + expectedDescs[expected.length - 1]\n          : expectedDescs[0];\n\n        foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n        return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n      }\n\n      var posDetails = peg$computePosDetails(pos),\n          found      = pos < input.length ? input.charAt(pos) : null;\n\n      if (expected !== null) {\n        cleanupExpected(expected);\n      }\n\n      return new SyntaxError(\n        message !== null ? message : buildMessage(expected, found),\n        expected,\n        found,\n        pos,\n        posDetails.line,\n        posDetails.column\n      );\n    }\n\n    function peg$parsetext() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 173 + 0,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_parenthetical();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_parenthetical();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseparagraphs();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsespaces();\n          if (s4 === peg$FAILED) {\n            s4 = peg$c2;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseEOF();\n            if (s5 === peg$FAILED) {\n              s5 = peg$c2;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c3(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseparagraphs() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 1,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseparagraph();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$currPos;\n        s5 = peg$currPos;\n        peg$silentFails++;\n        s6 = peg$parsePU_clause();\n        peg$silentFails--;\n        if (s6 !== peg$FAILED) {\n          peg$currPos = s5;\n          s5 = peg$c4;\n        } else {\n          s5 = peg$c0;\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parseparagraph();\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$currPos;\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parsePU_clause();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parseparagraph();\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c5(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseparagraph() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 173 + 2,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsePU_clause();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseparagraph_unit();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$currPos;\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$parsePA_clause();\n          if (s7 === peg$FAILED) {\n            s7 = peg$parsePO_clause();\n          }\n          peg$silentFails--;\n          if (s7 !== peg$FAILED) {\n            peg$currPos = s6;\n            s6 = peg$c4;\n          } else {\n            s6 = peg$c0;\n          }\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parseparagraph_unit();\n            if (s7 !== peg$FAILED) {\n              s6 = [s6, s7];\n              s5 = s6;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$c0;\n          }\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$currPos;\n            s6 = peg$currPos;\n            peg$silentFails++;\n            s7 = peg$parsePA_clause();\n            if (s7 === peg$FAILED) {\n              s7 = peg$parsePO_clause();\n            }\n            peg$silentFails--;\n            if (s7 !== peg$FAILED) {\n              peg$currPos = s6;\n              s6 = peg$c4;\n            } else {\n              s6 = peg$c0;\n            }\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parseparagraph_unit();\n              if (s7 !== peg$FAILED) {\n                s6 = [s6, s7];\n                s5 = s6;\n              } else {\n                peg$currPos = s5;\n                s5 = peg$c0;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c6(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseparagraph_unit() {\n      var s0, s1;\n\n      var key    = peg$currPos * 173 + 3,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsedefinition();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsesentence();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c7(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsearguments_list() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 173 + 4,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parseKA_clause();\n      if (s3 === peg$FAILED) {\n        s3 = peg$parseGA_clause();\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parseKA_clause();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parseGA_clause();\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsePI_clause();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c8(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsedefinition() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 173 + 5,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsePO_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsedefinition_key();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsescope();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsePOI_clause_elidible();\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c9(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsedefinition_key() {\n      var s0, s1;\n\n      var key    = peg$currPos * 173 + 6,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseGA_clause();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsepredicate_compound();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsepredicate_root();\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c10(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsesentence() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 173 + 7,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsePA_clause_elidible();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsescope();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsePAI_clause_elidible();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c11(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsescope() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 173 + 8,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsearguments_list();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsescope_1();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c12(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsescope_1() {\n      var s0, s1;\n\n      var key    = peg$currPos * 173 + 9,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsescope_list();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsescope_2();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c13(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsescope_list() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 10,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsescope_list_element();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$currPos;\n        s5 = peg$parseBU_clause();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parsescope_list_element();\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n        if (s4 !== peg$FAILED) {\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$currPos;\n            s5 = peg$parseBU_clause();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsescope_list_element();\n              if (s6 !== peg$FAILED) {\n                s5 = [s5, s6];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$c0;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          }\n        } else {\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c14(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsescope_list_element() {\n      var s0, s1;\n\n      var key    = peg$currPos * 173 + 11,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsescope_2();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c15(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsescope_2() {\n      var s0, s1;\n\n      var key    = peg$currPos * 173 + 12,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsechaining();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c16(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsechaining() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 173 + 13,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsechaining_neg();\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = peg$parsechaining_unit();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsechaining();\n          if (s3 === peg$FAILED) {\n            s3 = peg$c2;\n          }\n          if (s3 !== peg$FAILED) {\n            s2 = [s2, s3];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c17(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsechaining_neg() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 173 + 14,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseBI_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsechaining_unit();\n        if (s4 !== peg$FAILED) {\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parsechaining_unit();\n          }\n        } else {\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c18(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsechaining_unit() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 173 + 15,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsepredicate();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseva_scope();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c19(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseva_scope() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 173 + 16,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseva_scope_first();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parseva_scope_next();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parseva_scope_next();\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseVAI_clause_elidible();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c20(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseva_scope_first() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 173 + 17,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseBI_clause();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseVA_clause();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsescope();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c21(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseva_scope_next() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 173 + 18,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseBI_clause();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseFA_clause();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsescope();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c22(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepredicate() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 173 + 19,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parseSA_clause();\n      if (s3 === peg$FAILED) {\n        s3 = peg$parseZA_clause();\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parseSA_clause();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parseZA_clause();\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsepredicate_1();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c23(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepredicate_1() {\n      var s0, s1;\n\n      var key    = peg$currPos * 173 + 20,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsepredicate_simple();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsepredicate_quote();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsepredicate_variable();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parsepredicate_scope();\n            if (s1 === peg$FAILED) {\n              s1 = peg$parsepredicate_borrowing();\n              if (s1 === peg$FAILED) {\n                s1 = peg$parsepredicate_root();\n                if (s1 === peg$FAILED) {\n                  s1 = peg$parsepredicate_number();\n                  if (s1 === peg$FAILED) {\n                    s1 = peg$parsepredicate_compound();\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c24(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepredicate_root() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 21,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseroot();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c25(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepredicate_number() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 22,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsenumber();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c26(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepredicate_compound() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 23,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsecompound();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c27(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepredicate_borrowing() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 173 + 24,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseborrowing_group();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$parsefree_post();\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parsefree_post();\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c28(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepredicate_scope() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 173 + 25,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsePE_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsescope();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsePEI_clause_elidible();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c29(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepredicate_quote() {\n      var s0, s1;\n\n      var key    = peg$currPos * 173 + 26,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsegrammatical_quote();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseone_word_quote();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseforeign_quote();\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c30(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsegrammatical_quote() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 173 + 27,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseLA_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsetext();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseLAI_clause();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c31(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseone_word_quote() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 173 + 28,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseLE_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsenative_word();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c32(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseforeign_quote() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\n      var key    = peg$currPos * 173 + 29,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseLO_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseforeign_quote_open();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsespaces();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseforeign_quote_content();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseforeign_quote_close();\n                if (s7 !== peg$FAILED) {\n                  s8 = [];\n                  s9 = peg$parsefree_post();\n                  while (s9 !== peg$FAILED) {\n                    s8.push(s9);\n                    s9 = peg$parsefree_post();\n                  }\n                  if (s8 !== peg$FAILED) {\n                    s2 = [s2, s3, s4, s5, s6, s7, s8];\n                    s1 = s2;\n                  } else {\n                    peg$currPos = s1;\n                    s1 = peg$c0;\n                  }\n                } else {\n                  peg$currPos = s1;\n                  s1 = peg$c0;\n                }\n              } else {\n                peg$currPos = s1;\n                s1 = peg$c0;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c33(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseforeign_quote_content() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 173 + 30,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$currPos;\n      s3 = peg$parseforeign_quote_word();\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsespaces();\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$c0;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$c0;\n      }\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$currPos;\n        s3 = peg$parseforeign_quote_word();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsespaces();\n          if (s4 !== peg$FAILED) {\n            s3 = [s3, s4];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$c0;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$c0;\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c34(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenumber() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 173 + 31,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parseTA_clause();\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parseTA_clause();\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseBE_clause_elidible();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c35(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseborrowing_group() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 173 + 32,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsespaces();\n      if (s4 === peg$FAILED) {\n        s4 = peg$c2;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseborrowing();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$c0;\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parsespaces();\n          if (s4 === peg$FAILED) {\n            s4 = peg$c2;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseborrowing();\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseBE_clause_elidible();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c36(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepredicate_simple() {\n      var s0, s1;\n\n      var key    = peg$currPos * 173 + 33,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseBA_clause();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseMA_clause();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c37(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepredicate_variable() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 173 + 34,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseBO_clause();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseKA_clause();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parseGA_clause();\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c38(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefree_prefix() {\n      var s0, s1;\n\n      var key    = peg$currPos * 173 + 35,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseDA_clause();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c39(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefree_post() {\n      var s0, s1;\n\n      var key    = peg$currPos * 173 + 36,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsefree_parenthetical();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsefree_subscript();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c40(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefree_subscript() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 173 + 37,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseDI_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsenumber();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c41(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefree_parenthetical() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 173 + 38,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseDO_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsetext();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseDOI_clause();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c42(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseoverride() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 173 + 39,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseDU_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseGA_clause();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parseBA_clause();\n          if (s3 === peg$FAILED) {\n            s3 = peg$parseoverride_word();\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c43(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseoverride_word() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 173 + 40,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseroot();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parsecompound();\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c44(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBA_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 41,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseBA();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c45(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBE_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 42,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseBE();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c46(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBI_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 43,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseBI();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c47(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBO_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 44,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseBO();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c48(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBU_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 45,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseBU();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c49(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDA_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 173 + 46,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseDA();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c50(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDI_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 47,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseDI();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c51(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDO_clause() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 173 + 48,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseDO();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c52(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDOI_clause() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 173 + 49,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseDOI();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c53(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDU_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 50,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseDU();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c54(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseSA_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 51,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseSA();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseoverride();\n              if (s6 === peg$FAILED) {\n                s6 = peg$c2;\n              }\n              if (s6 !== peg$FAILED) {\n                s2 = [s2, s3, s4, s5, s6];\n                s1 = s2;\n              } else {\n                peg$currPos = s1;\n                s1 = peg$c0;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c55(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseZA_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 52,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseZA();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseoverride();\n              if (s6 === peg$FAILED) {\n                s6 = peg$c2;\n              }\n              if (s6 !== peg$FAILED) {\n                s2 = [s2, s3, s4, s5, s6];\n                s1 = s2;\n              } else {\n                peg$currPos = s1;\n                s1 = peg$c0;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c56(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseVA_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 53,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseVA();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseoverride();\n              if (s6 === peg$FAILED) {\n                s6 = peg$c2;\n              }\n              if (s6 !== peg$FAILED) {\n                s2 = [s2, s3, s4, s5, s6];\n                s1 = s2;\n              } else {\n                peg$currPos = s1;\n                s1 = peg$c0;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c57(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseFA_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 54,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseFA();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseoverride();\n              if (s6 === peg$FAILED) {\n                s6 = peg$c2;\n              }\n              if (s6 !== peg$FAILED) {\n                s2 = [s2, s3, s4, s5, s6];\n                s1 = s2;\n              } else {\n                peg$currPos = s1;\n                s1 = peg$c0;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c58(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseVAI_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 55,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseVAI();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c59(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseGA_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 56,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseGA();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c60(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseKA_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 57,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseKA();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c61(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseMA_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 58,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseMA();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c62(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePA_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 59,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsePA();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c63(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePAI_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 60,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsePAI();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c64(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePE_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 61,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsePE();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c65(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePEI_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 62,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsePEI();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c66(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePI_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 63,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsePI();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c67(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePO_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 64,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsePO();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c68(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePOI_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 65,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsePOI();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c69(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePU_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 66,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsePU();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c70(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseTA_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 67,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseTA();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c71(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseLA_clause() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 173 + 68,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseLA();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c72(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseLAI_clause() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 173 + 69,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseLAI();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$parsefree_post();\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parsefree_post();\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c73(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseLE_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 70,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseLE();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c74(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseLO_clause() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 173 + 71,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseLO();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c75(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBE_clause_elidible() {\n      var s0, s1;\n\n      var key    = peg$currPos * 173 + 72,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseBE_clause();\n      if (s1 === peg$FAILED) {\n        s1 = peg$c2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c76(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePA_clause_elidible() {\n      var s0, s1;\n\n      var key    = peg$currPos * 173 + 73,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsePA_clause();\n      if (s1 === peg$FAILED) {\n        s1 = peg$c2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c77(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePAI_clause_elidible() {\n      var s0, s1;\n\n      var key    = peg$currPos * 173 + 74,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsePAI_clause();\n      if (s1 === peg$FAILED) {\n        s1 = peg$c2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c78(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePEI_clause_elidible() {\n      var s0, s1;\n\n      var key    = peg$currPos * 173 + 75,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsePEI_clause();\n      if (s1 === peg$FAILED) {\n        s1 = peg$c2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c79(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePOI_clause_elidible() {\n      var s0, s1;\n\n      var key    = peg$currPos * 173 + 76,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsePOI_clause();\n      if (s1 === peg$FAILED) {\n        s1 = peg$c2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c80(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseVAI_clause_elidible() {\n      var s0, s1;\n\n      var key    = peg$currPos * 173 + 77,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseVAI_clause();\n      if (s1 === peg$FAILED) {\n        s1 = peg$c2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c81(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBA() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 173 + 78,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parseb();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsea();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c82(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBE() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 79,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parseb();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parsee();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehaeiou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c83(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBI() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 173 + 80,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parseb();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsei();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c84(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBO() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 173 + 81,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parseb();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseo();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c85(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBU() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 173 + 82,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parseb();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseu();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c86(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseCA() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 173 + 83,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsec();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsehaeiou();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c87(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDA() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 84,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsed();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parsea();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehaeiou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c88(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDI() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 173 + 85,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsed();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsei();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c89(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDO() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 173 + 86,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsed();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseo();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c90(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDOI() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 87,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsed();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseo();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsei();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c91(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDU() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 173 + 88,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsed();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseu();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c92(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseFA() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 173 + 89,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsef();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsehaeiou();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c93(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseGA() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 173 + 90,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parseg();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsehaeiou();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c94(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseKA() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 173 + 91,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsek();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsehaeiou();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c95(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseMA() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 173 + 92,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsem();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsehaeiou();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c96(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePA() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 173 + 93,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$currPos;\n        s5 = peg$parsePAI();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s7 !== peg$FAILED) {\n            peg$currPos = s6;\n            s6 = peg$c4;\n          } else {\n            s6 = peg$c0;\n          }\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          s5 = peg$parsep();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$currPos;\n            peg$silentFails++;\n            s7 = peg$parsea();\n            peg$silentFails--;\n            if (s7 !== peg$FAILED) {\n              peg$currPos = s6;\n              s6 = peg$c4;\n            } else {\n              s6 = peg$c0;\n            }\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsehaeiou();\n              if (s7 !== peg$FAILED) {\n                s5 = [s5, s6, s7];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$c0;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parsepost_word();\n            peg$silentFails--;\n            if (s6 !== peg$FAILED) {\n              peg$currPos = s5;\n              s5 = peg$c4;\n            } else {\n              s5 = peg$c0;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c97(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePAI() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 94,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsep();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsea();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsei();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c98(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePE() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 173 + 95,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsep();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsee();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c99(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePEI() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 96,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsep();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsee();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsei();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c100(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePI() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 97,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsep();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parsei();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehaeiou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c101(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePO() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 173 + 98,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$currPos;\n        s5 = peg$parsePOI();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s7 !== peg$FAILED) {\n            peg$currPos = s6;\n            s6 = peg$c4;\n          } else {\n            s6 = peg$c0;\n          }\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          s5 = peg$parsep();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$currPos;\n            peg$silentFails++;\n            s7 = peg$parseo();\n            peg$silentFails--;\n            if (s7 !== peg$FAILED) {\n              peg$currPos = s6;\n              s6 = peg$c4;\n            } else {\n              s6 = peg$c0;\n            }\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsehaeiou();\n              if (s7 !== peg$FAILED) {\n                s5 = [s5, s6, s7];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$c0;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parsepost_word();\n            peg$silentFails--;\n            if (s6 !== peg$FAILED) {\n              peg$currPos = s5;\n              s5 = peg$c4;\n            } else {\n              s5 = peg$c0;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c102(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePOI() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 99,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsep();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseo();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsei();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c103(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePU() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 100,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsep();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parseu();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehaeiou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c104(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseSA() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 173 + 101,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parses();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsehaeiou();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c105(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseTA() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 173 + 102,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parset();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsehaeiou();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = peg$parsedigit();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          peg$silentFails++;\n          s4 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s4 !== peg$FAILED) {\n            peg$currPos = s3;\n            s3 = peg$c4;\n          } else {\n            s3 = peg$c0;\n          }\n          if (s3 !== peg$FAILED) {\n            s2 = [s2, s3];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c106(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseVA() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 173 + 103,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$currPos;\n        s5 = peg$parseVAI();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s7 !== peg$FAILED) {\n            peg$currPos = s6;\n            s6 = peg$c4;\n          } else {\n            s6 = peg$c0;\n          }\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          s5 = peg$parsev();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehaeiou();\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parsepost_word();\n            peg$silentFails--;\n            if (s6 !== peg$FAILED) {\n              peg$currPos = s5;\n              s5 = peg$c4;\n            } else {\n              s5 = peg$c0;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c107(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseVAI() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 104,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsev();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsea();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsei();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c108(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseLA() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 173 + 105,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$currPos;\n        s5 = peg$parseLAI();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s7 !== peg$FAILED) {\n            peg$currPos = s6;\n            s6 = peg$c4;\n          } else {\n            s6 = peg$c0;\n          }\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          s5 = peg$parsel();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$currPos;\n            peg$silentFails++;\n            s7 = peg$parsea();\n            peg$silentFails--;\n            if (s7 !== peg$FAILED) {\n              peg$currPos = s6;\n              s6 = peg$c4;\n            } else {\n              s6 = peg$c0;\n            }\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsehaeiou();\n              if (s7 !== peg$FAILED) {\n                s5 = [s5, s6, s7];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$c0;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parsepost_word();\n            peg$silentFails--;\n            if (s6 !== peg$FAILED) {\n              peg$currPos = s5;\n              s5 = peg$c4;\n            } else {\n              s5 = peg$c0;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c109(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseLAI() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 106,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsel();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsea();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsei();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c110(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseLE() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 107,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsel();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parsee();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehaeiou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c111(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseLO() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 108,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsel();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parseo();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehaeiou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c112(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseZA() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 173 + 109,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsez();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsehaeiou();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c113(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseforeign_quote_open() {\n      var s0, s1;\n\n      var key    = peg$currPos * 173 + 110,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsenative_word();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c114(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseforeign_quote_word() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 173 + 111,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$currPos;\n      s3 = peg$currPos;\n      peg$silentFails++;\n      s4 = peg$parsespace_char();\n      peg$silentFails--;\n      if (s4 === peg$FAILED) {\n        s3 = peg$c4;\n      } else {\n        peg$currPos = s3;\n        s3 = peg$c0;\n      }\n      if (s3 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c115); }\n        }\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$c0;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$currPos;\n          s3 = peg$currPos;\n          peg$silentFails++;\n          s4 = peg$parsespace_char();\n          peg$silentFails--;\n          if (s4 === peg$FAILED) {\n            s3 = peg$c4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n          if (s3 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s4 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c115); }\n            }\n            if (s4 !== peg$FAILED) {\n              s3 = [s3, s4];\n              s2 = s3;\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c0;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$c0;\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = peg$currPos;\n        s2 = peg$c116(s1);\n        if (s2) {\n          s2 = peg$c0;\n        } else {\n          s2 = peg$c4;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c117(s1);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseforeign_quote_close() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 173 + 112,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsenative_word();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = peg$currPos;\n        s2 = peg$c116(s1);\n        if (s2) {\n          s2 = peg$c4;\n        } else {\n          s2 = peg$c0;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c118(s1);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecompound() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 173 + 113,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsecompound_2();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parsecompound_3();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parsecompound_4();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parsecompound_n();\n          }\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsepost_word();\n        peg$silentFails--;\n        if (s4 !== peg$FAILED) {\n          peg$currPos = s3;\n          s3 = peg$c4;\n        } else {\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c119(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecompound_2() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 173 + 114,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsee();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecompound_word();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsecompound_word();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c120(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecompound_3() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 173 + 115,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsei();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecompound_word();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsecompound_word();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsecompound_word();\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c121(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecompound_4() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 116,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseo();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecompound_word();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsecompound_word();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsecompound_word();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsecompound_word();\n              if (s6 !== peg$FAILED) {\n                s2 = [s2, s3, s4, s5, s6];\n                s1 = s2;\n              } else {\n                peg$currPos = s1;\n                s1 = peg$c0;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c122(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecompound_n() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 173 + 117,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsea();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecompound_word();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$currPos;\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$parsecompound_n_end();\n          peg$silentFails--;\n          if (s7 === peg$FAILED) {\n            s6 = peg$c4;\n          } else {\n            peg$currPos = s6;\n            s6 = peg$c0;\n          }\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parsecompound_word();\n            if (s7 !== peg$FAILED) {\n              s6 = [s6, s7];\n              s5 = s6;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$c0;\n          }\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$currPos;\n            s6 = peg$currPos;\n            peg$silentFails++;\n            s7 = peg$parsecompound_n_end();\n            peg$silentFails--;\n            if (s7 === peg$FAILED) {\n              s6 = peg$c4;\n            } else {\n              peg$currPos = s6;\n              s6 = peg$c0;\n            }\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsecompound_word();\n              if (s7 !== peg$FAILED) {\n                s6 = [s6, s7];\n                s5 = s6;\n              } else {\n                peg$currPos = s5;\n                s5 = peg$c0;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsecompound_n_end();\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c123(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecompound_n_end() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 173 + 118,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsea();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c124(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecompound_word() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 173 + 119,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseborrowing();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parsenative_word();\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c125(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseborrowing() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 120,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseu();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsespaces();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parseu();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 === peg$FAILED) {\n          s3 = peg$currPos;\n          peg$silentFails++;\n          s4 = peg$parseu();\n          peg$silentFails--;\n          if (s4 === peg$FAILED) {\n            s3 = peg$c4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseborrowing_content();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseborrowing_end();\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c126(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseborrowing_content() {\n      var s0, s1;\n\n      var key    = peg$currPos * 173 + 121,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseforeign_word();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c127(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseborrowing_end() {\n      var s0, s1;\n\n      var key    = peg$currPos * 173 + 122,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsepause_char();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsespace_char();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseEOF();\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c128(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseforeign_word() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 173 + 123,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseinitial_consonant_pair();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseconsonant();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parseh();\n        }\n      }\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsehaeiou();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$currPos;\n          s6 = peg$parseconsonant_cluster();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parsehaeiou();\n            if (s7 !== peg$FAILED) {\n              s6 = [s6, s7];\n              s5 = s6;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$c0;\n          }\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$currPos;\n            s6 = peg$parseconsonant_cluster();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsehaeiou();\n              if (s7 !== peg$FAILED) {\n                s6 = [s6, s7];\n                s5 = s6;\n              } else {\n                peg$currPos = s5;\n                s5 = peg$c0;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsesonorant();\n            if (s5 === peg$FAILED) {\n              s5 = peg$c2;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c129(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenative_word() {\n      var s0, s1;\n\n      var key    = peg$currPos * 173 + 124,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseroot();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseparticle();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c130(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseparticle() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 173 + 125,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parsesonorant();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = peg$c4;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseparticle_1();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c131(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseroot() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 173 + 126,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parsesonorant();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = peg$c4;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseroot_1();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parseroot_2();\n          if (s3 === peg$FAILED) {\n            s3 = peg$parseroot_3();\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c132(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseparticle_1() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 173 + 127,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseconsonant();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsehaeiou();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c133(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseroot_1() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 173 + 128,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseconsonant();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsehaeiou();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$currPos;\n          s6 = peg$parsesonorant();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parsehaeiou();\n            if (s7 !== peg$FAILED) {\n              s6 = [s6, s7];\n              s5 = s6;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              s5 = peg$currPos;\n              s6 = peg$parsesonorant();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsehaeiou();\n                if (s7 !== peg$FAILED) {\n                  s6 = [s6, s7];\n                  s5 = s6;\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$c0;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$c0;\n              }\n            }\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsesonorant();\n            if (s5 === peg$FAILED) {\n              s5 = peg$c2;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c134(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseroot_2() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 173 + 129,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseconsonant();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsehaeiou();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsesonorant();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c135(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseroot_3() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 173 + 130,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseinitial_consonant_pair();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsehaeiou();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$currPos;\n          s6 = peg$parsesonorant();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parsehaeiou();\n            if (s7 !== peg$FAILED) {\n              s6 = [s6, s7];\n              s5 = s6;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$c0;\n          }\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$currPos;\n            s6 = peg$parsesonorant();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsehaeiou();\n              if (s7 !== peg$FAILED) {\n                s6 = [s6, s7];\n                s5 = s6;\n              } else {\n                peg$currPos = s5;\n                s5 = peg$c0;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsesonorant();\n            if (s5 === peg$FAILED) {\n              s5 = peg$c2;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c136(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsehaeiou() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 173 + 131,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parseaeiou();\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parseaeiou();\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$currPos;\n        s5 = peg$parseh();\n        if (s5 !== peg$FAILED) {\n          s6 = [];\n          s7 = peg$parseaeiou();\n          if (s7 !== peg$FAILED) {\n            while (s7 !== peg$FAILED) {\n              s6.push(s7);\n              s7 = peg$parseaeiou();\n            }\n          } else {\n            s6 = peg$c0;\n          }\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$currPos;\n          s5 = peg$parseh();\n          if (s5 !== peg$FAILED) {\n            s6 = [];\n            s7 = peg$parseaeiou();\n            if (s7 !== peg$FAILED) {\n              while (s7 !== peg$FAILED) {\n                s6.push(s7);\n                s7 = peg$parseaeiou();\n              }\n            } else {\n              s6 = peg$c0;\n            }\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c137(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseaeiou() {\n      var s0, s1;\n\n      var key    = peg$currPos * 173 + 132,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsea();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsee();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsei();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parseo();\n            if (s1 === peg$FAILED) {\n              s1 = peg$parseu();\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c138(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseconsonant_cluster() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 173 + 133,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$currPos;\n      s4 = peg$parsesonorant();\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsesonorant();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parsesonorant();\n          if (s6 !== peg$FAILED) {\n            s4 = [s4, s5, s6];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$c0;\n      }\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = peg$c4;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseconsonant();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseconsonant();\n          if (s4 === peg$FAILED) {\n            s4 = peg$c2;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseconsonant();\n            if (s5 === peg$FAILED) {\n              s5 = peg$c2;\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$currPos;\n              peg$silentFails++;\n              s7 = peg$parseconsonant();\n              peg$silentFails--;\n              if (s7 === peg$FAILED) {\n                s6 = peg$c4;\n              } else {\n                peg$currPos = s6;\n                s6 = peg$c0;\n              }\n              if (s6 !== peg$FAILED) {\n                s2 = [s2, s3, s4, s5, s6];\n                s1 = s2;\n              } else {\n                peg$currPos = s1;\n                s1 = peg$c0;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c139(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseinitial_consonant_pair() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 134,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseinitial();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseconsonant();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseconsonant();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parseconsonant();\n            peg$silentFails--;\n            if (s6 === peg$FAILED) {\n              s5 = peg$c4;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c140(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseinitial() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 173 + 135,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseplosib();\n      if (s2 === peg$FAILED) {\n        s2 = peg$currPos;\n        s3 = peg$parsesibilant();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseother();\n          if (s4 === peg$FAILED) {\n            s4 = peg$c2;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseliquid();\n            if (s5 === peg$FAILED) {\n              s5 = peg$c2;\n            }\n            if (s5 !== peg$FAILED) {\n              s3 = [s3, s4, s5];\n              s2 = s3;\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c0;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$c0;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$c0;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parseconsonant();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c141(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseplosib() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 173 + 136,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseplosive();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsesibilant();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c142(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseconsonant() {\n      var s0, s1;\n\n      var key    = peg$currPos * 173 + 137,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsevoiced();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseunvoiced();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseliquid();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parsem();\n            if (s1 === peg$FAILED) {\n              s1 = peg$parsen();\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c143(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseliquid() {\n      var s0, s1;\n\n      var key    = peg$currPos * 173 + 138,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsel();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parser();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c144(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseother() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 173 + 139,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsep();\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = peg$parset();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          peg$silentFails++;\n          s4 = peg$parsel();\n          peg$silentFails--;\n          if (s4 === peg$FAILED) {\n            s3 = peg$c4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n          if (s3 !== peg$FAILED) {\n            s2 = [s2, s3];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsek();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parsef();\n            if (s1 === peg$FAILED) {\n              s1 = peg$parseb();\n              if (s1 === peg$FAILED) {\n                s1 = peg$currPos;\n                s2 = peg$parsed();\n                if (s2 !== peg$FAILED) {\n                  s3 = peg$currPos;\n                  peg$silentFails++;\n                  s4 = peg$parsel();\n                  peg$silentFails--;\n                  if (s4 === peg$FAILED) {\n                    s3 = peg$c4;\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$c0;\n                  }\n                  if (s3 !== peg$FAILED) {\n                    s2 = [s2, s3];\n                    s1 = s2;\n                  } else {\n                    peg$currPos = s1;\n                    s1 = peg$c0;\n                  }\n                } else {\n                  peg$currPos = s1;\n                  s1 = peg$c0;\n                }\n                if (s1 === peg$FAILED) {\n                  s1 = peg$parseg();\n                  if (s1 === peg$FAILED) {\n                    s1 = peg$parsev();\n                    if (s1 === peg$FAILED) {\n                      s1 = peg$parsem();\n                      if (s1 === peg$FAILED) {\n                        s1 = peg$currPos;\n                        s2 = peg$parsen();\n                        if (s2 !== peg$FAILED) {\n                          s3 = peg$currPos;\n                          peg$silentFails++;\n                          s4 = peg$parseliquid();\n                          peg$silentFails--;\n                          if (s4 === peg$FAILED) {\n                            s3 = peg$c4;\n                          } else {\n                            peg$currPos = s3;\n                            s3 = peg$c0;\n                          }\n                          if (s3 !== peg$FAILED) {\n                            s2 = [s2, s3];\n                            s1 = s2;\n                          } else {\n                            peg$currPos = s1;\n                            s1 = peg$c0;\n                          }\n                        } else {\n                          peg$currPos = s1;\n                          s1 = peg$c0;\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c145(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseplosive() {\n      var s0, s1;\n\n      var key    = peg$currPos * 173 + 140,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parset();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsed();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsek();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parseg();\n            if (s1 === peg$FAILED) {\n              s1 = peg$parsep();\n              if (s1 === peg$FAILED) {\n                s1 = peg$parseb();\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c146(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsesibilant() {\n      var s0, s1;\n\n      var key    = peg$currPos * 173 + 141,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsec();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parses();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsej();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parsez();\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c147(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsesonorant() {\n      var s0, s1;\n\n      var key    = peg$currPos * 173 + 142,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsen();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parser();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c148(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsevoiced() {\n      var s0, s1;\n\n      var key    = peg$currPos * 173 + 143,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseb();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsed();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseg();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parsej();\n            if (s1 === peg$FAILED) {\n              s1 = peg$parsev();\n              if (s1 === peg$FAILED) {\n                s1 = peg$parsez();\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c149(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseunvoiced() {\n      var s0, s1;\n\n      var key    = peg$currPos * 173 + 144,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsec();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsef();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsek();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parsep();\n            if (s1 === peg$FAILED) {\n              s1 = peg$parses();\n              if (s1 === peg$FAILED) {\n                s1 = peg$parset();\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c150(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsea() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 173 + 145,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c151.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c152); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsea();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c153(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsee() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 173 + 146,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c154.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c155); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsee();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c156(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsei() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 173 + 147,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c157.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c158); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsei();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c159(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseo() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 173 + 148,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c160.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c161); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parseo();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c162(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseu() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 173 + 149,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c163.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c164); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parseu();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c165(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseh() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 173 + 150,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c166.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c167); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parseh();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c168(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsen() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 173 + 151,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c169.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c170); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsen();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c171(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parser() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 173 + 152,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c172.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c173); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parser();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c174(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseb() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 173 + 153,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c175.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c176); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parseb();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parseunvoiced();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c4;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c177(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsed() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 173 + 154,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c178.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c179); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsed();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parseunvoiced();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c4;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c180(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseg() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 173 + 155,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c181.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c182); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parseg();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parseunvoiced();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c4;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c183(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsev() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 173 + 156,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c184.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c185); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsev();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parseunvoiced();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c4;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c186(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsej() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 157,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c187.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c188); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsej();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsez();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c4;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parseunvoiced();\n            peg$silentFails--;\n            if (s6 === peg$FAILED) {\n              s5 = peg$c4;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c189(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsez() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 158,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c190.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c191); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsez();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsej();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c4;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parseunvoiced();\n            peg$silentFails--;\n            if (s6 === peg$FAILED) {\n              s5 = peg$c4;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c192(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parses() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 159,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c193.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c194); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parses();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsec();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c4;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parsevoiced();\n            peg$silentFails--;\n            if (s6 === peg$FAILED) {\n              s5 = peg$c4;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c195(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsec() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 160,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c196.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c197); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsec();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parses();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c4;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parsevoiced();\n            peg$silentFails--;\n            if (s6 === peg$FAILED) {\n              s5 = peg$c4;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c198(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsek() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 173 + 161,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c199.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c200); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsek();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsevoiced();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c4;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c201(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsef() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 173 + 162,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c202.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c203); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsef();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsevoiced();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c4;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c204(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsep() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 173 + 163,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c205.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c206); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsep();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsevoiced();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c4;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c207(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parset() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 173 + 164,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c208.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c209); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parset();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsevoiced();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c4;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c210(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsem() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 173 + 165,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c211.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c212); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsem();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c213(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsel() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 173 + 166,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c214.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c215); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsel();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c216(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepost_word() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 173 + 167,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsepause_char();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parseaeiou();\n        peg$silentFails--;\n        if (s4 !== peg$FAILED) {\n          peg$currPos = s3;\n          s3 = peg$c4;\n        } else {\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = peg$currPos;\n        peg$silentFails++;\n        s3 = peg$parsesonorant();\n        peg$silentFails--;\n        if (s3 === peg$FAILED) {\n          s2 = peg$c4;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$c0;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          peg$silentFails++;\n          s4 = peg$parseconsonant();\n          peg$silentFails--;\n          if (s4 !== peg$FAILED) {\n            peg$currPos = s3;\n            s3 = peg$c4;\n          } else {\n            s3 = peg$c0;\n          }\n          if (s3 !== peg$FAILED) {\n            s2 = [s2, s3];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsespaces();\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c217(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsespaces() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 173 + 168,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsespace_char();\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsespace_char();\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsepause_char();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parseaeiou();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = peg$parsepause_char();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          peg$silentFails++;\n          s4 = peg$parseaeiou();\n          peg$silentFails--;\n          if (s4 !== peg$FAILED) {\n            peg$currPos = s3;\n            s3 = peg$c4;\n          } else {\n            s3 = peg$c0;\n          }\n          if (s3 !== peg$FAILED) {\n            s2 = [s2, s3];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseEOF();\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c218(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepause_char() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 173 + 169,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c219.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c220); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsepause_char();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c221(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsespace_char() {\n      var s0, s1;\n\n      var key    = peg$currPos * 173 + 170,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (peg$c222.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c223); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c224(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsedigit() {\n      var s0, s1;\n\n      var key    = peg$currPos * 173 + 171,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (peg$c225.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c226); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c227(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseEOF() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 173 + 172,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      peg$silentFails++;\n      if (input.length > peg$currPos) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c115); }\n      }\n      peg$silentFails--;\n      if (s2 === peg$FAILED) {\n        s1 = peg$c4;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c228(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n\n      var _g_foreign_quote_delim;\n\n      function _join(arg) {\n        if (typeof(arg) == \"string\")\n          return arg;\n        else if (arg) {\n          var ret = \"\";\n          for (var v in arg) { if (arg[v]) ret += _join(arg[v]); }\n          return ret;\n        }\n      }\n\n      function _node_empty(label, arg) {\n        var ret = [];\n        if (label) ret.push(label);\n        if (arg && typeof arg == \"object\" && typeof arg[0] == \"string\" && arg[0]) {\n          ret.push( arg );\n          return ret;\n        }\n        if (!arg)\n        {\n          return ret;\n        }\n        return _node_int(label, arg);\n      }\n\n      function _node_int(label, arg) {\n        if (typeof arg == \"string\")\n          return arg;\n        if (!arg) arg = [];\n        var ret = [];\n        if (label) ret.push(label);\n        for (var v in arg) {\n          if (arg[v] && arg[v].length != 0)\n            ret.push( _node_int( null, arg[v] ) );\n        }\n        return ret;\n      }\n\n      function _node2(label, arg1, arg2) {\n        return [label].concat(_node_empty(arg1)).concat(_node_empty(arg2));\n      }\n\n      function _node(label, arg) {\n        var _n = _node_empty(label, arg);\n        return (_n.length == 1 && label) ? [] : _n;\n      }\n      var _node_nonempty = _node;\n\n      // === Functions for faking left recursion === //\n\n      function _flatten_node(a) {\n        // Flatten nameless nodes\n        // e.g. [Name1, [[Name2, X], [Name3, Y]]] --> [Name1, [Name2, X], [Name3, Y]]\n        if (is_array(a)) {\n          var i = 0;\n          while (i < a.length) {\n            if (!is_array(a[i])) i++;\n            else if (a[i].length === 0) // Removing []s\n              a = a.slice(0, i).concat(a.slice(i + 1));\n            else if (is_array(a[i][0]))\n              a = a.slice(0, i).concat(a[i], a.slice(i + 1));\n            else i++;\n          }\n        }\n        return a;\n      }\n\n      function _group_leftwise(arr) {\n        if (!is_array(arr)) return [];\n        else if (arr.length <= 2) return arr;\n        else return [_group_leftwise(arr.slice(0, -1)), arr[arr.length - 1]];\n      }\n\n      // \"_lg\" for \"Leftwise Grouping\".\n      function _node_lg(label, arg) {\n        return _node(label, _group_leftwise(_flatten_node(arg)));\n      }\n\n      function _node_lg2(label, arg) {\n        if (is_array(arg) && arg.length == 2)\n          arg = arg[0].concat(arg[1]);\n        return _node(label, _group_leftwise(arg));\n      }\n\n      // === Foreign words functions === //\n\n      function _assign_foreign_quote_delim(w) {\n        if (is_array(w)) w = join_expr(w);\n        else if (!is_string(w)) throw \"ERROR: foreign_quote word is of type \" + typeof w;\n        w = w.toLowerCase().replace(/,/gm,\"\").replace(/h/g, \"'\");\n        _g_foreign_quote_delim = w;\n        return;\n      }\n\n      function _is_foreign_quote_delim(w) {\n        if (is_array(w)) w = join_expr(w);\n        else if (!is_string(w)) throw \"ERROR: foreign_quote word is of type \" + typeof w;\n        /* Keeping spaces in the parse tree seems to result in the absorbtion of\n           spaces into the closing delimiter candidate, so we'll remove any space\n           character from our input. */\n        w = w.replace(/[.\\t\\n\\r?!\\u0020]/g, \"\");\n        w = w.toLowerCase().replace(/,/gm,\"\").replace(/h/g, \"'\");\n        return w === _g_foreign_quote_delim;\n      }\n\n      function join_expr(n) {\n        if (!is_array(n) || n.length < 1) return \"\";\n        var s = \"\";\n        var i = is_array(n[0]) ? 0 : 1;\n        while (i < n.length) {\n          s += is_string(n[i]) ? n[i] : join_expr(n[i]);\n          i++;\n        }\n        return s;\n      }\n\n      function is_string(v) {\n        // return $.type(v) === \"string\";\n        return Object.prototype.toString.call(v) === '[object String]';\n      }\n\n      function is_array(v) {\n        // return $.type(v) === \"array\";\n        return Object.prototype.toString.call(v) === '[object Array]';\n      }\n\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail({ type: \"end\", description: \"end of input\" });\n      }\n\n      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n    }\n  }\n\n  return {\n    SyntaxError: SyntaxError,\n    parse:       parse\n  };\n})()\nmodule.exports.camxes = camxes;\n\n\n//# sourceURL=webpack://bundle/./grammar/eberban.js?");

/***/ }),

/***/ "../dictionary/en.yaml":
/*!*****************************!*\
  !*** ../dictionary/en.yaml ***!
  \*****************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"0\":{\"family\":\"TA\",\"long\":\"Digit 0\",\"short\":\"ta\"},\"1\":{\"family\":\"TA\",\"long\":\"Digit 1\",\"short\":\"te\"},\"2\":{\"family\":\"TA\",\"long\":\"Digit 2\",\"short\":\"to\"},\"3\":{\"family\":\"TA\",\"long\":\"Digit 3\",\"short\":\"tu\"},\"4\":{\"family\":\"TA\",\"long\":\"Digit 4\",\"short\":\"tia\"},\"5\":{\"family\":\"TA\",\"long\":\"Digit 5\",\"short\":\"tie\"},\"6\":{\"family\":\"TA\",\"long\":\"Digit 6\",\"short\":\"tio\"},\"7\":{\"family\":\"TA\",\"long\":\"Digit 7\",\"short\":\"tiu\"},\"8\":{\"family\":\"TA\",\"long\":\"Digit 8\",\"short\":\"tai\"},\"9\":{\"family\":\"TA\",\"long\":\"Digit 9\",\"short\":\"tei\"},\"_cardinal\":{\"long\":\"(Ac) is (a group of) [number] things satisfying [E1].\"},\"_number\":{\"long\":\"(An) is the (abstract) number [number] with dimension/unit [E1]\\\\n(default: contextual, usually explicited by another unit).\\\\n\"},\"a\":{\"family\":\"A\",\"long\":\"Surround an arbitrary long compound.\",\"short\":\"\"},\"e\":{\"family\":\"E\",\"long\":\"Prefix a 2 words long compound.\",\"short\":\"\"},\"i\":{\"family\":\"I\",\"long\":\"Prefix a 3 words long compound.\",\"short\":\"\"},\"o\":{\"family\":\"O\",\"long\":\"Prefix a 4 words long compound.\",\"short\":\"\"},\"u\":{\"family\":\"U\",\"long\":\"Borrowing: (Ad) is a [word].\",\"short\":\"\"},\"mi\":{\"family\":\"MA\",\"long\":\"(Ad) is I/me/a speaker/author.\",\"short\":\"me\"},\"mo\":{\"family\":\"MA\",\"long\":\"(Ad) is you, a listener.\",\"short\":\"you\"},\"mio\":{\"family\":\"MA\",\"long\":\"(Ad) is I/a speaker/author or you, a listener.\",\"short\":\"we\"},\"ma\":{\"family\":\"MA\",\"long\":\"(Ad) is not bound outside of this scope.\\\\n\\\\nCan be used with {sen} to define the default meaning of a unbound parameter.\\\\nUse {zoi} for predicate places.\\\\n\",\"short\":\"unbound\"},\"me\":{\"family\":\"MA\",\"long\":\"(Ad) is someone, neither a speaker or listener.\",\"short\":\"other\"},\"mai\":{\"family\":\"MA\",\"long\":\"(Ad) is indefinite specific.\\\\nThe speaker has a specific individual in mind, but the listener is not\\\\nexpected to know which one.\\\\n\",\"short\":\"a\"},\"mao\":{\"family\":\"MA\",\"long\":\"(Ad) is definite specific.\\\\nThe speaker has a specific individual in mind and the listener is expected\\\\nto know which one from context.\\\\n\",\"short\":\"the\"},\"mei\":{\"family\":\"MA\",\"long\":\"(Ad) is this here, near a speaker.\",\"short\":\"this\"},\"meo\":{\"family\":\"MA\",\"long\":\"(Ad) is that here, near a listener.\",\"short\":\"that\"},\"meu\":{\"family\":\"MA\",\"long\":\"(Ad) is that yonder, far from speaker and listener.\",\"short\":\"that yonder\"},\"mua\":{\"family\":\"MA\",\"long\":\"(A0) is the last/previous proposition.\",\"short\":\"last prop\"},\"mue\":{\"family\":\"MA\",\"long\":\"(A0) is the proposition (0-ary scope) in which this one is embeded.\",\"short\":\"outer prop\"},\"mui\":{\"family\":\"MA\",\"long\":\"(A0) is the current proposition.\",\"short\":\"current prop\"},\"muo\":{\"family\":\"MA\",\"long\":\"(A0) is the next proposition.\",\"short\":\"next prop\"},\"ba\":{\"family\":\"BA\",\"long\":\"Inline argument marker.\",\"short\":\"[inline arg]\"},\"ta\":{\"family\":\"TA\",\"long\":\"Digit 0\",\"short\":\"0\",\"tags\":[\"digit\",\"number\"]},\"te\":{\"family\":\"TA\",\"long\":\"Digit 1\",\"short\":\"1\",\"tags\":[\"digit\",\"number\"]},\"to\":{\"family\":\"TA\",\"long\":\"Digit 2\",\"short\":\"2\",\"tags\":[\"digit\",\"number\"]},\"tu\":{\"family\":\"TA\",\"long\":\"Digit 3\",\"short\":\"3\",\"tags\":[\"digit\",\"number\"]},\"tia\":{\"family\":\"TA\",\"long\":\"Digit 4\",\"short\":\"4\",\"tags\":[\"digit\",\"number\"]},\"tie\":{\"family\":\"TA\",\"long\":\"Digit 5\",\"short\":\"5\",\"tags\":[\"digit\",\"number\"]},\"tio\":{\"family\":\"TA\",\"long\":\"Digit 6\",\"short\":\"6\",\"tags\":[\"digit\",\"number\"]},\"tiu\":{\"family\":\"TA\",\"long\":\"Digit 7\",\"short\":\"7\",\"tags\":[\"digit\",\"number\"]},\"tai\":{\"family\":\"TA\",\"long\":\"Digit 8\",\"short\":\"8\",\"tags\":[\"digit\",\"number\"]},\"tei\":{\"family\":\"TA\",\"long\":\"Digit 9\",\"short\":\"9\",\"tags\":[\"digit\",\"number\"]},\"toi\":{\"family\":\"TA\",\"long\":\"Digit ↊/A (10)\",\"short\":\"A\",\"tags\":[\"digit\",\"number\"]},\"tui\":{\"family\":\"TA\",\"long\":\"Digit ↋/B (11)\",\"short\":\"B\",\"tags\":[\"digit\",\"number\"]},\"taia\":{\"family\":\"TA\",\"long\":\"Digit C (12)\",\"short\":\"C\",\"tags\":[\"digit\",\"number\"]},\"taie\":{\"family\":\"TA\",\"long\":\"Digit D (13)\",\"short\":\"D\",\"tags\":[\"digit\",\"number\"]},\"taio\":{\"family\":\"TA\",\"long\":\"Digit E (14)\",\"short\":\"E\",\"tags\":[\"digit\",\"number\"]},\"taiu\":{\"family\":\"TA\",\"long\":\"Digit F (15)\",\"short\":\"F\",\"tags\":[\"digit\",\"number\"]},\"ti\":{\"family\":\"TA\",\"long\":\"Decimal separator\",\"short\":\".\",\"tags\":[\"separator\",\"number\"]},\"tiha\":{\"family\":\"TA\",\"long\":\"<base . number> separator\",\"short\":\"base\",\"tags\":[\"separator\",\"number\"]},\"tihe\":{\"family\":\"TA\",\"long\":\"<precise . approximation> separator\",\"short\":\"approx\",\"tags\":[\"separator\",\"number\"]},\"tihi\":{\"family\":\"TA\",\"long\":\"<precise . repeating part> separator\",\"short\":\"repeating\",\"tags\":[\"separator\",\"number\"]},\"tiho\":{\"family\":\"TA\",\"long\":\"<numerator . denominator> separator\",\"short\":\"fraction\",\"tags\":[\"separator\",\"number\"]},\"taha\":{\"family\":\"TA\",\"long\":\"10^3 separator (kilo)\",\"short\":\"10^3\",\"tags\":[\"separator\",\"number\"]},\"tahe\":{\"family\":\"TA\",\"long\":\"10^6 separator (mega)\",\"short\":\"10^6\",\"tags\":[\"separator\",\"number\"]},\"taho\":{\"family\":\"TA\",\"long\":\"10^9 separator (giga)\",\"short\":\"10^9\",\"tags\":[\"separator\",\"number\"]},\"tahu\":{\"family\":\"TA\",\"long\":\"10^12 separator (tera)\",\"short\":\"10^12\",\"tags\":[\"separator\",\"number\"]},\"tahia\":{\"family\":\"TA\",\"long\":\"10^15 separator (peta)\",\"short\":\"10^15\",\"tags\":[\"separator\",\"number\"]},\"tahie\":{\"family\":\"TA\",\"long\":\"10^18 separator (exa)\",\"short\":\"10^18\",\"tags\":[\"separator\",\"number\"]},\"tahio\":{\"family\":\"TA\",\"long\":\"10^21 separator (zetta)\",\"short\":\"10^21\",\"tags\":[\"separator\",\"number\"]},\"tahiu\":{\"family\":\"TA\",\"long\":\"10^24 separator (yotta)\",\"short\":\"10^24\",\"tags\":[\"separator\",\"number\"]},\"tae\":{\"family\":\"TA\",\"long\":\"negative sign\",\"short\":\"-\",\"tags\":[\"number\"]},\"teha\":{\"family\":\"TA\",\"long\":\"Vector tag 0\",\"short\":\"vec 0\",\"tags\":[\"separator\",\"number\"]},\"tehe\":{\"family\":\"TA\",\"long\":\"Vector tag 1\",\"short\":\"vec 1\",\"tags\":[\"separator\",\"number\"]},\"teho\":{\"family\":\"TA\",\"long\":\"Vector tag 2\",\"short\":\"vec 2\",\"tags\":[\"separator\",\"number\"]},\"tehu\":{\"family\":\"TA\",\"long\":\"Vector tag 3\",\"short\":\"vec 3\",\"tags\":[\"separator\",\"number\"]},\"tehia\":{\"family\":\"TA\",\"long\":\"Vector tag 4\",\"short\":\"vec 4\",\"tags\":[\"separator\",\"number\"]},\"tehie\":{\"family\":\"TA\",\"long\":\"Vector tag 5\",\"short\":\"vec 5\",\"tags\":[\"separator\",\"number\"]},\"tehio\":{\"family\":\"TA\",\"long\":\"Vector tag 6\",\"short\":\"vec 6\",\"tags\":[\"separator\",\"number\"]},\"tehiu\":{\"family\":\"TA\",\"long\":\"Vector tag 7\",\"short\":\"vec 7\",\"tags\":[\"separator\",\"number\"]},\"la\":{\"family\":\"LA\",\"long\":\"Starts grammatically correct eberban quote. (Ad) is text [quote].\",\"short\":\"\"},\"lai\":{\"family\":\"LAI\",\"long\":\"Ends grammatically correct eberban quote.\",\"short\":\"\",\"tags\":[\"terminator\"]},\"le\":{\"family\":\"LE\",\"long\":\"Quote next word. (Ad) is word [word].\",\"short\":\"[word]\"},\"lei\":{\"family\":\"LE\",\"long\":\"(Ad) is the family of word [word].\",\"short\":\"[family]\"},\"leu\":{\"family\":\"LE\",\"long\":\"Provides a predicate describing the meaning of the following particle.\",\"short\":\"[meaning]\"},\"lo\":{\"family\":\"LO\",\"long\":\"(Ad) is a quote of an arbitrary string of space separated \\\\\"words\\\\\".\",\"short\":\"\"},\"fa\":{\"family\":\"FA\",\"long\":\"Switch to the A place of the predicate before the current VA-scope.\",\"short\":\"switch-A\"},\"fe\":{\"family\":\"FA\",\"long\":\"Switch to the E place of the predicate before the current VA-scope.\",\"short\":\"switch-E\"},\"fi\":{\"family\":\"FA\",\"long\":\"Switch to the I place of the predicate before the current VA-scope.\",\"short\":\"switch-I\"},\"fo\":{\"family\":\"FA\",\"long\":\"Switch to the O place of the predicate before the current VA-scope.\",\"short\":\"switch-O\"},\"fai\":{\"family\":\"FA\",\"long\":\"Switch to the implicit switch place of the predicate before the current VA-scope.\",\"short\":\"switch-implicit\"},\"fua\":{\"family\":\"FA\",\"long\":\"Switch to the same place as the previous FA/VA.\",\"short\":\"switch-same\"},\"fue\":{\"family\":\"FA\",\"long\":\"Switch to the next place relative to the previous FA/VA.\",\"short\":\"switch-next\"},\"va\":{\"family\":\"VA\",\"long\":\"Switch to the A place of the predicate word before it, and start a VA-scope.\",\"short\":\"〈 switch-A\"},\"ve\":{\"family\":\"VA\",\"long\":\"Switch to the E place of the predicate word before it, and start a VA-scope.\",\"short\":\"〈 switch-E\"},\"vi\":{\"family\":\"VA\",\"long\":\"Switch to the I place of the predicate word before it, and start a VA-scope.\",\"short\":\"〈 switch-I\"},\"vo\":{\"family\":\"VA\",\"long\":\"Switch to the O place of the predicate word before it, and start a VA-scope.\",\"short\":\"〈 switch-O\"},\"vai\":{\"family\":\"VAI\",\"long\":\"Close the current VA-scope.\",\"short\":\"〉\",\"tags\":[\"terminator\",\"elidable\"]},\"sa\":{\"family\":\"SA\",\"long\":\"(A) place binding tag.\",\"short\":\"(A)\"},\"se\":{\"family\":\"SA\",\"long\":\"(E) place binding tag.\",\"short\":\"(E)\"},\"si\":{\"family\":\"SA\",\"long\":\"(I) place binding tag.\",\"short\":\"(I)\"},\"so\":{\"family\":\"SA\",\"long\":\"(O) place binding tag.\",\"short\":\"(O)\"},\"za\":{\"family\":\"ZA\",\"long\":\"(Ac) is named [predicate-(A)].\",\"short\":\"named\"},\"ze\":{\"family\":\"ZA\",\"long\":\"Use the same instance and variables of the following unit instead of a new one.\",\"short\":\"same\"},\"zi\":{\"family\":\"ZA\",\"long\":\"Narrow-scope negation : negates the predicate unit but not the existential variables it creates.\\\\nThere exist a, e,... such that unit(a, e, ...) is false.\\\\n\",\"short\":\"non-\",\"tags\":[\"negation\"]},\"zo\":{\"family\":\"ZA\",\"long\":\"(Ac) is something referred to by [predicate-A].\",\"short\":\"deref\"},\"zoi\":{\"family\":\"ZA\",\"long\":\"(Ac) is a reference/symbol refering to [predicate].\",\"short\":\"ref\"},\"pa\":{\"family\":\"PA\",\"long\":\"Starts an assertive sentence, that can be believed or disbelieved, and is either true or false.\",\"short\":\"[assertion]\"},\"pae\":{\"family\":\"PA\",\"long\":\"Starts an vocative. Defines the listener as the (A) place of this scope.\",\"short\":\"[vocative]\"},\"pao\":{\"family\":\"PA\",\"long\":\"Starts a declarative sentence, that is true only because uttered (used for declarations, announcements, etc).\",\"short\":\"[declaration]\"},\"pau\":{\"family\":\"PA\",\"long\":\"Starts a directive sentence, that is requested, wished or ordered to be true.\",\"short\":\"[directive]\"},\"pai\":{\"family\":\"PAI\",\"long\":\"Ends an predicate scope.\",\"short\":\"\",\"tags\":[\"terminator\",\"elidable\"]},\"pe\":{\"family\":\"PE\",\"long\":\"Inline scope starter.\",\"short\":\"[\"},\"pei\":{\"family\":\"PEI\",\"long\":\"Inline scope elidible terminator.\",\"short\":\"]\",\"tags\":[\"terminator\",\"elidable\"]},\"pi\":{\"family\":\"PI\",\"long\":\"Ends the list of arguments.\",\"short\":\"[args end]\"},\"pia\":{\"family\":\"PI\",\"long\":\"Ends the list of arguments, and mark the scope as a switch (E place) predicate.\",\"short\":\"[args end seq]\"},\"po\":{\"family\":\"PO\",\"long\":\"Start a predicate definition.\",\"short\":\"[definition]\"},\"poa\":{\"family\":\"PO\",\"long\":\"Start a question definition, the arguments being the unknown informations.\",\"short\":\"[question]\"},\"poi\":{\"family\":\"POI\",\"long\":\"Ends a predicate definition.\",\"short\":\"\",\"tags\":[\"terminator\",\"elidable\"]},\"pu\":{\"family\":\"PU\",\"long\":\"Marks a new paragraph/section/change of subject.\",\"short\":\"[paragraph]\"},\"da\":{\"family\":\"DA\",\"long\":\"Emphasis indicator : the next word is especially emphasized.\",\"short\":\"[emphasis]\"},\"daha\":{\"family\":\"DA\",\"long\":\"Nonce-word indicator : the next word (usually a compound) may be non-standard.\",\"short\":\"[non-standard]\"},\"dahe\":{\"family\":\"DA\",\"long\":\"Next word is a metadata tag / hashtag.\",\"short\":\"[metadata]\"},\"dae\":{\"family\":\"DA\",\"long\":\"However/but/in contrast.\",\"short\":\"[however]\"},\"dai\":{\"family\":\"DA\",\"long\":\"Similarly.\",\"short\":\"[similarly]\"},\"dao\":{\"family\":\"DA\",\"long\":\"Additionally.\",\"short\":\"[additionally]\"},\"dau\":{\"family\":\"DA\",\"long\":\"Uniquely/only/solely.\",\"short\":\"[uniquely]\"},\"di\":{\"family\":\"DI\",\"long\":\"Attaches a subscript number/string.\",\"short\":\"[subscript]\"},\"du\":{\"family\":\"DU\",\"long\":\"Override particule meaning with provided predicate.\",\"short\":\"[override]\"},\"do\":{\"family\":\"DO\",\"long\":\"Starts parenthetical note.\",\"short\":\"(\"},\"doi\":{\"family\":\"DOI\",\"long\":\"Ends parenthetical note.\",\"short\":\")\",\"tags\":[\"terminator\"]},\"bu\":{\"family\":\"BU\",\"long\":\"List separator.\",\"short\":\"[list]\"},\"be\":{\"family\":\"BE\",\"long\":\"Ends string/number/borrowing.\",\"short\":\"\",\"tags\":[\"terminator\",\"elidable\",\"number\"]},\"bei\":{\"family\":\"BE\",\"long\":\"Transform a cardinal number into an ordinal : (Ac) is the [number]th member of ordered list [Es].\",\"short\":\"-th\",\"switch\":true,\"tags\":[\"terminator\",\"number\"]},\"bi\":{\"family\":\"BI\",\"long\":\"Wide scope negation ranging over existential variables, units and bindings.\",\"short\":\"not\",\"tags\":[\"negation\"]},\"bo\":{\"family\":\"BO\",\"long\":\"Create a new variable and discard previous value if any.\",\"short\":\"new var\"},\"kor\":{\"family\":\"R\",\"long\":\"(Ac) [group] are the members of list [Es].\",\"short\":\"group\",\"switch\":true,\"tags\":[\"list\"]},\"cna\":{\"family\":\"R\",\"long\":\"This proposition is true if all individuals in list (As) satisfies property [E1].\",\"short\":\"AND-I\",\"switch\":true,\"tags\":[\"list\",\"connective\"]},\"cne\":{\"family\":\"R\",\"long\":\"This proposition is true if at least one individual in list (As) satisfies property [E1].\",\"short\":\"OR-I\",\"switch\":true,\"tags\":[\"list\",\"connective\"]},\"cni\":{\"family\":\"R\",\"long\":\"This proposition is true if exactly (In) (default: 1) individuals in list (As) satisfies property [E1].\",\"short\":\"XOR-I\",\"switch\":true,\"tags\":[\"list\",\"connective\"]},\"cana\":{\"family\":\"R\",\"long\":\"This proposition is true if all propositions in list (As0) are true.\",\"short\":\"AND-P0\",\"tags\":[\"list\",\"connective\"]},\"cane\":{\"family\":\"R\",\"long\":\"This proposition is true if at least one proposition in list (As0) is true.\",\"short\":\"OR-P0\",\"tags\":[\"list\",\"connective\"]},\"cani\":{\"family\":\"R\",\"long\":\"This proposition is true if exactly (En) (default: 1) proposition(s) in list (As0) is true.\",\"short\":\"XOR-P0\",\"tags\":[\"list\",\"connective\"]},\"cena\":{\"family\":\"R\",\"long\":\"This proposition is true if (Ac) satisfies all properties in list [Es1].\",\"short\":\"AND-P1\",\"switch\":true,\"tags\":[\"list\",\"connective\"]},\"cene\":{\"family\":\"R\",\"long\":\"This proposition is true if (Ac) satisfies at least one property in list [Es1].\",\"short\":\"OR-P1\",\"switch\":true,\"tags\":[\"list\",\"connective\"]},\"ceni\":{\"family\":\"R\",\"long\":\"This proposition is true if (Ac) satisfies exactly (In) (default: 1) proposition(s) in list [Es1].\",\"short\":\"XOR-P1\",\"switch\":true,\"tags\":[\"list\",\"connective\"]},\"cina\":{\"family\":\"R\",\"long\":\"This proposition is true if (Ac) and (Ec) satisfies all relations in list (Is2).\",\"short\":\"AND-P2\",\"tags\":[\"list\",\"connective\"]},\"cine\":{\"family\":\"R\",\"long\":\"This proposition is true if (Ac) and (Ec) satisfies at least one relation in list (Is2).\",\"short\":\"OR-P2\",\"tags\":[\"list\",\"connective\"]},\"cini\":{\"family\":\"R\",\"long\":\"This proposition is true if (Ac) and (Ec) satisfies exactly (On) (default: 1) relation(s) in list (Is2).\",\"short\":\"XOR-P2\",\"tags\":[\"list\",\"connective\"]},\"kano\":{\"family\":\"R\",\"long\":\"(Ac) satisfies more property [E1] than (Ic) (default: average thing satisfying property [E1]).\\\\n[E1] should express a property that can be compared and ordered.\\\\n\",\"short\":\"more\",\"switch\":true},\"gere\":{\"family\":\"R\",\"long\":\"(Ac) satisfies less property [E1] than (Ic) (default: average thing satisfying property [E1]).\\\\n[E1] should express a property that can be compared and ordered.\\\\n\",\"short\":\"less\",\"switch\":true},\"fuir\":{\"family\":\"R\",\"long\":\"(Ad) knows fact [E0] from source (Id).\",\"short\":\"knows\",\"switch\":true},\"zvu\":{\"family\":\"R\",\"long\":\"(Ac) satisfy relation [E2] with its future self. \\\\nAllow to describe the evolution of something.\\\\n\\\\n[E2] is used with (future, current) in this order.\\\\n\",\"short\":\"evolution\",\"switch\":true},\"zde\":{\"family\":\"R\",\"long\":\"(A0) (default: now) is true/occurs concurrently with/at the same time as [E0] (default: now).\",\"short\":\"present\",\"switch\":true,\"tags\":[\"time\"]},\"skir\":{\"family\":\"R\",\"long\":\"(Ad) (default: speaker) is at the same place as [Ed] (default: speaker).\",\"short\":\"same place\",\"switch\":true,\"tags\":[\"space\"]},\"jgo\":{\"family\":\"R\",\"long\":\"(A0) (default: now) occurs before [E0] (default: now).\",\"short\":\"before\",\"switch\":true,\"tags\":[\"time\"]},\"slo\":{\"family\":\"R\",\"long\":\"(A0) (default: now) occurs after [E0] (default: now).\",\"short\":\"after\",\"switch\":true,\"tags\":[\"time\"]},\"pcei\":{\"family\":\"R\",\"long\":\"(Ad) (default: speaker) is backward/to the back of [Ed] (default: speaker).\",\"short\":\"back\",\"switch\":true,\"tags\":[\"space\",\"direction\"]},\"vlo\":{\"family\":\"R\",\"long\":\"(Ad) (default: speaker) is forward/to the front of [Ed] (default: speaker).\",\"short\":\"front\",\"switch\":true,\"tags\":[\"space\",\"direction\"]},\"fle\":{\"family\":\"R\",\"long\":\"(Ad) (default: speaker) is leftward/to the left of [Ed] (default: speaker).\",\"short\":\"left\",\"switch\":true,\"tags\":[\"space\",\"direction\"]},\"zre\":{\"family\":\"R\",\"long\":\"(Ad) (default: speaker) is rightward/to the right of [Ed] (default: speaker).\",\"short\":\"right\",\"switch\":true,\"tags\":[\"space\",\"direction\"]},\"gze\":{\"family\":\"R\",\"long\":\"(Ad) (default: speaker) is below/downwars/down from [Ed] (default: speaker).\",\"short\":\"down\",\"switch\":true,\"tags\":[\"space\",\"direction\"]},\"bri\":{\"family\":\"R\",\"long\":\"(Ad) (default: speaker) is above/upward/up from [Ed] (default: speaker).\",\"short\":\"up\",\"switch\":true,\"tags\":[\"space\",\"direction\"]},\"cfae\":{\"family\":\"R\",\"long\":\"(Ad) (default: speaker) is southward/to the south of [Ed] (default: speaker).\",\"short\":\"south\",\"switch\":true,\"tags\":[\"space\",\"direction\"]},\"jgao\":{\"family\":\"R\",\"long\":\"(Ad) (default: speaker) is northward/to the north of [Ed] (default: speaker).\",\"short\":\"north\",\"switch\":true,\"tags\":[\"space\",\"direction\"]},\"troe\":{\"family\":\"R\",\"long\":\"(Ad) (default: speaker) is westward/to the west of [Ed] (default: speaker).\",\"short\":\"west\",\"switch\":true,\"tags\":[\"space\",\"direction\"]},\"glea\":{\"family\":\"R\",\"long\":\"(Ad) (default: speaker) is eastward/to the east of [Ed] (default: speaker).\",\"short\":\"east\",\"switch\":true,\"tags\":[\"space\",\"direction\"]},\"vuno\":{\"family\":\"R\",\"long\":\"(Ad) is at a distance in space of [En] (default: 1 meter) from (Id) (default: speaker).\",\"short\":\"space distance\",\"switch\":true,\"tags\":[\"space\",\"measument\"]},\"ganu\":{\"family\":\"R\",\"long\":\"(A0) is true/occurs at a distance in time of [En] (default: 1 year) from (I0) (default: now).\",\"short\":\"time distance\",\"switch\":true,\"tags\":[\"time\",\"measument\"]},\"zini\":{\"family\":\"R\",\"long\":\"(A0) is true/occurs over time interval/length [En] (default: 1 year).\",\"short\":\"time length\",\"switch\":true,\"tags\":[\"time\",\"measument\"]},\"cunu\":{\"family\":\"R\",\"long\":\"(Ad) has length [En] (default: 1 meter).\",\"short\":\"length\",\"switch\":true,\"tags\":[\"space\",\"measument\"]},\"zono\":{\"family\":\"R\",\"long\":\"(Ad) has area [En] (default: 1 square meters).\",\"short\":\"area (measure)\",\"switch\":true,\"tags\":[\"space\",\"measument\"]},\"tana\":{\"family\":\"R\",\"long\":\"(Ad) has volume [En] (default: 1 cubic meter).\",\"short\":\"volume (measure)\",\"switch\":true,\"tags\":[\"space\",\"measument\"]},\"keun\":{\"family\":\"R\",\"long\":\"(Ad) (default: speaker) is at the starting point of [Ed].\",\"short\":\"space start\",\"switch\":true,\"tags\":[\"space\",\"interval\"]},\"daen\":{\"family\":\"R\",\"long\":\"(Ad) (default: speaker) is between the starting and end point of [Ed].\",\"short\":\"space between\",\"switch\":true,\"tags\":[\"space\",\"interval\"]},\"moan\":{\"family\":\"R\",\"long\":\"(Ad) (default: speaker) is at an halt/interruption of [Ed].\",\"short\":\"space halt\",\"switch\":true,\"tags\":[\"space\",\"interval\"]},\"taon\":{\"family\":\"R\",\"long\":\"(Ad) (default: speaker) is at the resumption of [Ed].\",\"short\":\"space resumption\",\"switch\":true,\"tags\":[\"space\",\"interval\"]},\"cuan\":{\"family\":\"R\",\"long\":\"(Ad) (default: speaker) is at the end point of [Ed].\",\"short\":\"space end\",\"switch\":true,\"tags\":[\"space\",\"interval\"]},\"keur\":{\"family\":\"R\",\"long\":\"(A0) (default: now) is at the starting point of [E0] (default: now).\",\"short\":\"time start\",\"switch\":true,\"tags\":[\"time\",\"interval\"]},\"daer\":{\"family\":\"R\",\"long\":\"(A0) (default: now) is between the starting and end point of [E0] (default: now).\",\"short\":\"time between\",\"switch\":true,\"tags\":[\"time\",\"interval\"]},\"moar\":{\"family\":\"R\",\"long\":\"(A0) (default: now) is at an halt/interruption of [E0] (default: now).\",\"short\":\"time halt\",\"switch\":true,\"tags\":[\"time\",\"interval\"]},\"taor\":{\"family\":\"R\",\"long\":\"(A0) (default: now) is at the resumption of [E0] (default: now).\",\"short\":\"time resumption\",\"switch\":true,\"tags\":[\"time\",\"interval\"]},\"cuar\":{\"family\":\"R\",\"long\":\"(A0) (default: now) is at the end point of [E0] (default: now).\",\"short\":\"time end\",\"switch\":true,\"tags\":[\"time\",\"interval\"]},\"mura\":{\"family\":\"R\",\"long\":\"(A0) is regular/occurs regularly.\",\"short\":\"regular\",\"tags\":[\"time\",\"interval\"]},\"geno\":{\"family\":\"R\",\"long\":\"(A0) is typical/occurs typically.\",\"short\":\"typical\",\"tags\":[\"time\",\"interval\"]},\"foru\":{\"family\":\"R\",\"long\":\"(A0) is continuous/occurs continuously.\",\"short\":\"continuous\",\"tags\":[\"time\",\"interval\"]},\"jenu\":{\"family\":\"R\",\"long\":\"(A0) is habitual/occurs habitually.\",\"short\":\"habitual\",\"tags\":[\"time\",\"interval\"]},\"fena\":{\"family\":\"R\",\"long\":\"(Ad) is inside/within [Ed].\",\"short\":\"inside\",\"tags\":[\"space\"]},\"laro\":{\"family\":\"R\",\"long\":\"(Ad) is outside [Ed].\",\"short\":\"outside\",\"switch\":true,\"tags\":[\"space\"]},\"suru\":{\"family\":\"R\",\"long\":\"(Ad) is adjacent to/along [Ed].\",\"short\":\"adjacent\",\"switch\":true,\"tags\":[\"space\"]},\"manu\":{\"family\":\"R\",\"long\":\"(Ad) is tangential/passing by [Ed].\",\"short\":\"passing by\",\"switch\":true,\"tags\":[\"space\"]},\"varu\":{\"family\":\"R\",\"long\":\"(Ad) is surrounding/around [Ed].\",\"short\":\"surrounding\",\"switch\":true,\"tags\":[\"space\"]},\"mere\":{\"family\":\"R\",\"long\":\"(Ad) is transfixing/passing through [Ed].\",\"short\":\"passing through\",\"switch\":true,\"tags\":[\"space\"]},\"tinu\":{\"family\":\"R\",\"long\":\"(Ad) is towards [Ed].\",\"short\":\"towards\",\"switch\":true,\"tags\":[\"space\"]},\"keru\":{\"family\":\"R\",\"long\":\"(Ad) is away from [Ed].\",\"short\":\"away from\",\"switch\":true,\"tags\":[\"space\"]},\"don\":{\"family\":\"R\",\"long\":\"(Ad) likes [Ed].\",\"short\":\"likes\",\"switch\":true,\"tags\":[\"emotion\"]},\"jven\":{\"family\":\"R\",\"long\":\"(Ad) is a friend of [Ed].\",\"short\":\"friend\",\"switch\":true,\"tags\":[\"emotion\"]},\"kli\":{\"family\":\"R\",\"long\":\"(Ad) thanks/is thankful to [Ed] about (I0) being true.\",\"short\":\"thanks\",\"switch\":true,\"tags\":[\"emotion\"]},\"kre\":{\"family\":\"R\",\"long\":\"(Ad) helps [Ed] to satisfy property (I1).\\\\n[Ed] is the one satisfying (I1), and (Ad) doesn\\'t need to satisfy (I1).\\\\n\",\"short\":\"helps\",\"switch\":true},\"luenu\":{\"family\":\"R\",\"long\":\"(Ad) is milk.\",\"short\":\"milk\"},\"mlian\":{\"family\":\"R\",\"long\":\"(Ad) is a cat.\",\"short\":\"cat\",\"tags\":[\"animal\"]},\"kcia\":{\"family\":\"R\",\"long\":\"(Ad) [tool] is used to make [I0] [purpose] true.\",\"short\":\"tool\",\"switch\":true},\"puana\":{\"family\":\"R\",\"long\":\"(Ad) drinks [Ed].\",\"short\":\"drinks\",\"switch\":true},\"bouri\":{\"family\":\"R\",\"long\":\"(Ad) eats [Ed].\",\"short\":\"eats\",\"switch\":true},\"sfe\":{\"family\":\"R\",\"long\":\"(Ad) is female.\",\"short\":\"female\"},\"kla\":{\"family\":\"R\",\"long\":\"(Ad) is male.\",\"short\":\"male\"},\"tsen\":{\"family\":\"R\",\"long\":\"(Ac) invents/creates/authors [Ed].\",\"short\":\"creates\",\"switch\":true},\"zuna\":{\"family\":\"R\",\"long\":\"(Ad) is inspired by [Ed]. [Ed] is a source of inspiration for (Ad).\",\"short\":\"inspired\",\"switch\":true},\"zvar\":{\"family\":\"R\",\"long\":\"(Ad) has goal/purpose/aims to satisfy [E1].\",\"short\":\"purpose\",\"switch\":true},\"skao\":{\"family\":\"R\",\"long\":\"(Ad) is a computer.\",\"short\":\"computer\"},\"sni\":{\"family\":\"R\",\"long\":\"(Ad) welcomes/say hello to/greets [Ed] to place (Id).\",\"short\":\"welcomes\",\"switch\":true},\"spi\":{\"family\":\"R\",\"long\":\"(Ad) says [Ed] to (Id).\",\"short\":\"says\",\"switch\":true},\"spur\":{\"family\":\"R\",\"long\":\"(Ad) is a nest/house/home for [Ed].\",\"short\":\"home\",\"switch\":true},\"zaor\":{\"family\":\"R\",\"long\":\"(Ad) agrees with [Ed] that (I0) is true.\",\"short\":\"agrees\",\"switch\":true},\"van\":{\"family\":\"R\",\"long\":\"(Ad) goes to [Ed] from (Id).\",\"short\":\"goes\",\"switch\":true},\"vanu\":{\"family\":\"R\",\"long\":\"(Ad) is a path to [Ed] from (Id).\",\"short\":\"path\",\"switch\":true},\"gza\":{\"family\":\"R\",\"long\":\"(Ac) is an agentive cause of event [E0].\",\"short\":\"agentive cause\",\"switch\":true},\"kini\":{\"family\":\"R\",\"long\":\"(Ad) learns/studies fact [E0] about (Id).\",\"short\":\"learns\",\"switch\":true},\"seru\":{\"family\":\"R\",\"long\":\"(Ad) is about subject [Ed].\",\"short\":\"about\",\"switch\":true},\"snai\":{\"family\":\"R\",\"long\":\"(Ac) labers/works by satisfying property [E1].\",\"short\":\"works\",\"switch\":true},\"bire\":{\"family\":\"R\",\"long\":\"(Ad) is a year.\",\"short\":\"year\",\"tags\":[\"time\",\"unit\"]},\"gare\":{\"family\":\"R\",\"long\":\"(Ad) is a month.\",\"short\":\"month\",\"tags\":[\"time\",\"unit\"]},\"kora\":{\"family\":\"R\",\"long\":\"(Ad) is a week.\",\"short\":\"week\",\"tags\":[\"time\",\"unit\"]},\"dena\":{\"family\":\"R\",\"long\":\"(Ad) is a day.\",\"short\":\"day\",\"tags\":[\"time\",\"unit\"]},\"sura\":{\"family\":\"R\",\"long\":\"(Ad) is a hour.\",\"short\":\"hour\",\"tags\":[\"time\",\"unit\"]},\"jero\":{\"family\":\"R\",\"long\":\"(Ad) is a minute.\",\"short\":\"minute\",\"tags\":[\"time\",\"unit\"]},\"cona\":{\"family\":\"R\",\"long\":\"(Ad) is a second.\",\"short\":\"second\",\"tags\":[\"time\",\"unit\"]},\"ber\":{\"family\":\"R\",\"long\":\"(Ad) reflects this language (eberban).\",\"short\":\"eberbanic\"},\"pre\":{\"family\":\"R\",\"long\":\"(Ad) is a person.\",\"short\":\"person\"},\"pra\":{\"family\":\"R\",\"long\":\"(Ad) loves [Ed].\",\"short\":\"loves\",\"switch\":true,\"tags\":[\"emotion\"]},\"vier\":{\"family\":\"R\",\"long\":\"(Ad) visits [Ed].\",\"short\":\"visits\",\"switch\":true},\"ten\":{\"family\":\"R\",\"long\":\"(Ac) is a small (subjective) amount of things satisfying [E1].\",\"short\":\"small amount of\",\"switch\":true,\"tags\":[\"group\"]},\"tin\":{\"family\":\"R\",\"long\":\"(Ac) is a medium (subjective) amount of things satisfying [E1].\",\"short\":\"medium amount of \",\"switch\":true,\"tags\":[\"group\"]},\"ton\":{\"family\":\"R\",\"long\":\"(Ac) is a large (subjective) amount of things satisfying [E1].\",\"short\":\"large amount of\",\"switch\":true,\"tags\":[\"group\"]},\"tun\":{\"family\":\"R\",\"long\":\"(Ac) is everything that satisfies [E1].\",\"short\":\"every\",\"switch\":true,\"tags\":[\"group\"]},\"tar\":{\"family\":\"R\",\"long\":\"(An) is a negligible number in dimension/unit [E1].\",\"short\":\"negligible\",\"switch\":true,\"tags\":[\"number\"]},\"ter\":{\"family\":\"R\",\"long\":\"(An) is a small number (subjective/contextual) in dimension/unit [E1].\",\"short\":\"small\",\"switch\":true,\"tags\":[\"number\"]},\"tir\":{\"family\":\"R\",\"long\":\"(An) is a medium number (subjective/contextual) in dimension/unit [E1].\",\"short\":\"medium\",\"switch\":true,\"tags\":[\"number\"]},\"tor\":{\"family\":\"R\",\"long\":\"(An) is a large number (subjective/contextual) in dimension/unit [E1].\",\"short\":\"large\",\"switch\":true,\"tags\":[\"number\"]},\"tur\":{\"family\":\"R\",\"long\":\"(An) is an infinite number in dimension/unit [E1].\",\"short\":\"infinite\",\"switch\":true,\"tags\":[\"number\"]},\"zbur\":{\"family\":\"R\",\"long\":\"(Ad) is a town/city.\",\"short\":\"city\"},\"zdir\":{\"family\":\"R\",\"long\":\"(Ad) is amusing/entertaining to (Ed) (default: speaker) in property (I1).\",\"short\":\"amusing\"},\"more\":{\"family\":\"R\",\"long\":\"(Ad) is simple in property (E1).\",\"short\":\"simple\"},\"tore\":{\"family\":\"R\",\"long\":\"(Ad) is complex/complicated in property (E1).\",\"short\":\"complicated\"},\"zane\":{\"family\":\"R\",\"long\":\"(Ad) is a system with components [Ed] forming structure (Id).\",\"short\":\"system\",\"switch\":true},\"dan\":{\"family\":\"R\",\"long\":\"(Ad) is among [Ec].\",\"short\":\"among\",\"switch\":true},\"dar\":{\"family\":\"R\",\"long\":\"Everything among (Ad) also satisfies [E1].\\\\nFor each x among (Ad), [E1](x) is true.\\\\n\",\"short\":\"for each\",\"switch\":true},\"speu\":{\"family\":\"R\",\"long\":\"(As_) (ordered list) is ordered following ordering rule [E2].\",\"short\":\"ordered set member\",\"switch\":true},\"fir\":{\"family\":\"R\",\"long\":\"(Ad) is a color of [Ed].\",\"short\":\"color\",\"switch\":true,\"tags\":[\"color\"]},\"cion\":{\"family\":\"R\",\"long\":\"(Ad) is [En] HSV-colored.\\\\n\\\\n[En] is a 3-vector with these components :\\\\n\\\\n{teha} : Hue of the color between 0 and 1.\\\\n         0 is red primary.\\\\n         1/3 is green primary.\\\\n         2/3 is blue primary.\\\\n         Default: 0\\\\n\\\\n{tehe} : Color saturation between 0 and 1.\\\\n         0 saturation is a shade of gray.\\\\n         Default: 1\\\\n\\\\n{teho} : Color value between 0 and 1.\\\\n         0 value is black.\\\\n         Default: 1\\\\n\",\"short\":\"HSV-color\",\"switch\":true,\"tags\":[\"color\"]},\"zen\":{\"family\":\"R\",\"long\":\"(Ad) is white/light [color adjective].\",\"short\":\"white\",\"tags\":[\"color\"]},\"gon\":{\"family\":\"R\",\"long\":\"(Ad) is black/dark [color adjective].\",\"short\":\"black\",\"tags\":[\"color\"]},\"bor\":{\"family\":\"R\",\"long\":\"(Ad) is red [color adjective].\",\"short\":\"red\",\"tags\":[\"color\"]},\"der\":{\"family\":\"R\",\"long\":\"(Ad) is green [color adjective].\",\"short\":\"green\",\"tags\":[\"color\"]},\"mir\":{\"family\":\"R\",\"long\":\"(Ad) is blue [color adjective].\",\"short\":\"blue\",\"tags\":[\"color\"]},\"zne\":{\"family\":\"R\",\"long\":\"(Ad) is cyan [color adjective].\",\"short\":\"cyan\",\"tags\":[\"color\"]},\"dzu\":{\"family\":\"R\",\"long\":\"(Ad) is magenta [color adjective].\",\"short\":\"magenta\",\"tags\":[\"color\"]},\"jgu\":{\"family\":\"R\",\"long\":\"(Ad) is yellow [color adjective].\",\"short\":\"yellow\",\"tags\":[\"color\"]},\"sare\":{\"family\":\"R\",\"long\":\"(Ac) is a group where every pair of members mutualy satisfy relation [E2].\",\"short\":\"mutual\",\"switch\":true},\"gli\":{\"family\":\"R\",\"long\":\"(Ad) is happy about [E0] being true.\",\"short\":\"happy\",\"switch\":true},\"siro\":{\"family\":\"R\",\"long\":\"(Ad) (source) has translation [Ed] (result).\",\"short\":\"translation\",\"switch\":true},\"cuina\":{\"family\":\"R\",\"long\":\"(dA) is a tree.\",\"short\":\"tree\"},\"jnaor\":{\"family\":\"R\",\"long\":\"(Ad) is wild/untamed.\",\"short\":\"wild\"},\"djin\":{\"family\":\"R\",\"long\":\"(Ad) desires/wants/wishes [E0].\",\"short\":\"want\",\"switch\":true},\"fuere\":{\"family\":\"R\",\"long\":\"(Ad) flies [in air/space].\",\"short\":\"fly\"},\"foina\":{\"family\":\"R\",\"long\":\"(Ad) is an airplane.\",\"short\":\"airplane\"},\"jle\":{\"family\":\"R\",\"long\":\"(Ad) is motivated to make [E0] true by (Id).\",\"short\":\"motivated\",\"switch\":true},\"zuan\":{\"family\":\"R\",\"long\":\"(Ad) walks.\",\"short\":\"walks\"},\"vune\":{\"family\":\"R\",\"long\":\"(Ad) is enjoyable/great/nice for [Ed].\",\"short\":\"nice\",\"switch\":true},\"jvin\":{\"family\":\"R\",\"long\":\"(Ad) dances.\",\"short\":\"dances\"},\"blan\":{\"family\":\"R\",\"long\":\"(Ad) is beautiful.\",\"short\":\"beautiful\"},\"kca\":{\"family\":\"R\",\"long\":\"(A0) is possible/can be true.\",\"short\":\"possible\"},\"pien\":{\"family\":\"R\",\"long\":\"(Ad) is bread.\",\"short\":\"bread\"},\"cnue\":{\"family\":\"R\",\"long\":\"(Ad) is a piece/portion/part of [Ec].\",\"short\":\"portion\",\"switch\":true},\"ban\":{\"family\":\"R\",\"long\":\"(Ad) is expressed in language [Ed].\",\"short\":\"language\",\"switch\":true},\"vin\":{\"family\":\"R\",\"long\":\"(Ad) is written/inscribed on display/storage medium [Ed].\",\"short\":\"written\",\"switch\":true},\"soane\":{\"family\":\"R\",\"long\":\"(Ad) is stolen from [Ed].\\\\n\\\\nUse with {gza} to express who/what steals (Ad).\\\\n\",\"short\":\"stolen\",\"switch\":true},\"sfa\":{\"family\":\"R\",\"long\":\"(Ad) is an occurence of [E0] being true.\",\"short\":\"occurence\",\"switch\":true},\"tcu\":{\"family\":\"R\",\"long\":\"(Ad) requires/needs [E0] to being true. [E0] is a necessity for (Ad).\",\"short\":\"needs\",\"switch\":true},\"minu\":{\"family\":\"R\",\"long\":\"(Ad) sleeps.\",\"short\":\"sleeps\"},\"jun\":{\"family\":\"R\",\"long\":\"(Ad) is good.\",\"short\":\"good\"},\"gur\":{\"family\":\"R\",\"long\":\"(Ad) is bad.\",\"short\":\"bad\"},\"kin\":{\"family\":\"R\",\"long\":\"(Ad) is a kind of [Ed].\",\"short\":\"kind\",\"switch\":true},\"kunu\":{\"family\":\"R\",\"long\":\"(Ad) feels sentiment/emotion/sensation [Ed].\",\"short\":\"feels\",\"switch\":true},\"viru\":{\"family\":\"R\",\"long\":\"(Ad) sees [Ed].\",\"short\":\"sees\",\"switch\":true},\"pure\":{\"family\":\"R\",\"long\":\"(Ad) hears/listen to [Ed].\",\"short\":\"hears\",\"switch\":true},\"len\":{\"family\":\"R\",\"long\":\"(Ad) is a word.\",\"short\":\"word\"},\"vina\":{\"family\":\"R\",\"long\":\"(Ad) is alive.\",\"short\":\"alive\"},\"mori\":{\"family\":\"R\",\"long\":\"(Ad) is dead.\",\"short\":\"dead\"},\"suer\":{\"family\":\"R\",\"long\":\"(Ad) is similar to/like [Ed].\",\"short\":\"similar\",\"switch\":true},\"paor\":{\"family\":\"R\",\"long\":\"(Ad) is the truth.\",\"short\":\"truth\"},\"cfeo\":{\"family\":\"R\",\"long\":\"(Ad) is a solid [state of matter].\",\"short\":\"solid\",\"tags\":[\"matter\"]},\"zrao\":{\"family\":\"R\",\"long\":\"(Ad) is a liquid [state of matter].\",\"short\":\"liquid\",\"tags\":[\"matter\"]},\"djio\":{\"family\":\"R\",\"long\":\"(Ad) is a gaz [state of matter].\",\"short\":\"gaz\",\"tags\":[\"matter\"]},\"leno\":{\"family\":\"R\",\"long\":\"(Ad) is water.\",\"short\":\"water\",\"tags\":[\"matter\"]},\"gouru\":{\"family\":\"R\",\"long\":\"(Ad) is a dog.\",\"short\":\"dog\",\"tags\":[\"animal\"]},\"kanae\":{\"family\":\"R\",\"long\":\"(Ad) is a wolf.\",\"short\":\"wolf\",\"tags\":[\"animal\"]},\"kroan\":{\"family\":\"R\",\"long\":\"(Ad) is a frog.\",\"short\":\"frog\",\"tags\":[\"animal\"]},\"tori\":{\"family\":\"R\",\"long\":\"(Ad) is a bird.\",\"short\":\"bird\",\"tags\":[\"animal\"]},\"cein\":{\"family\":\"R\",\"long\":\"(Ad) is a room.\",\"short\":\"room\"},\"caun\":{\"family\":\"R\",\"long\":\"(Ad) is an animal.\",\"short\":\"animal\",\"tags\":[\"animal\"]},\"flur\":{\"family\":\"R\",\"long\":\"(Ad) is a plant.\",\"short\":\"plant\"},\"bjan\":{\"family\":\"R\",\"long\":\"(Ad) is behaves friendly/kindly towards [Ed].\",\"short\":\"friendly\",\"switch\":true},\"lane\":{\"family\":\"R\",\"long\":\"(Ad) is a rule/law prescribing/mandating/requiring [E0].\",\"short\":\"rule\",\"switch\":true},\"zire\":{\"family\":\"R\",\"long\":\"(Ad) respects [Ed].\",\"short\":\"respects\",\"switch\":true},\"zvoe\":{\"family\":\"R\",\"long\":\"(Ad) is a content, something that is to be expressed though medium (Ed).\",\"short\":\"content\"},\"zbui\":{\"family\":\"R\",\"long\":\"(Ad) have sex/sexual intercourse/copulates/mates with [Ed].\",\"short\":\"sex\",\"switch\":true},\"jiro\":{\"family\":\"R\",\"long\":\"(Ad) shares [Ed] with (Id).\",\"short\":\"shares\",\"switch\":true},\"mare\":{\"family\":\"R\",\"long\":\"(Ad) is legal, allowed by authority (Ed).\",\"short\":\"allowed\"},\"sier\":{\"family\":\"R\",\"long\":\"(Ad) is the Internet.\",\"short\":\"internet\"},\"stini\":{\"family\":\"R\",\"long\":\"(Ad) is rigid/not bandable.\",\"short\":\"rigid\"},\"merue\":{\"family\":\"R\",\"long\":\"(Ad) is an organism / form of life.\",\"short\":\"organism\"},\"slaen\":{\"family\":\"R\",\"long\":\"(Ad) is tied/pinned to [Ed].\",\"short\":\"tied\",\"switch\":true},\"sfo\":{\"family\":\"R\",\"long\":\"(Ad) is something that contains this word.\",\"short\":\"this\"},\"skien\":{\"family\":\"R\",\"long\":\"(Ad) is a computer program.\",\"short\":\"program\"},\"sen\":{\"family\":\"R\",\"long\":\"If (A0) is true then [E0] is true, otherwise (I0) is true.\",\"short\":\"if then\"},\"zari\":{\"family\":\"R\",\"long\":\"(Ad) is a recipe, algorithm, procedure to achieve result [Ed].\",\"short\":\"recipe\",\"switch\":true},\"zein\":{\"family\":\"R\",\"long\":\"(Ad) [supply/commodity] is provided to [Ed].\\\\n\\\\nUse with {gza} to express who/what provides (Ad).\\\\n\",\"short\":\"provided\",\"switch\":true},\"curo\":{\"family\":\"R\",\"long\":\"(Ad) is the grammar of [Ed].\",\"short\":\"grammar\",\"switch\":true},\"cpena\":{\"family\":\"R\",\"long\":\"(Ad) is a document with content [Ed].\",\"short\":\"document\",\"switch\":true},\"tsir\":{\"family\":\"R\",\"long\":\"(Ad) finds/discovers [Ed].\",\"short\":\"finds\",\"switch\":true},\"tcon\":{\"family\":\"R\",\"long\":\"(Ad) is related to/associated wit/akin to [Ed] by relationship (I2).\",\"short\":\"related\",\"switch\":true},\"bun\":{\"family\":\"R\",\"long\":\"(Ad) is a version of [Ed].\",\"short\":\"version\",\"switch\":true},\"bju\":{\"family\":\"R\",\"long\":\"(Ad) is a text.\",\"short\":\"text\"},\"bion\":{\"family\":\"R\",\"long\":\"(Ad) is ill/sick from disease [Ed].\",\"short\":\"sick\",\"switch\":true},\"leun\":{\"family\":\"R\",\"long\":\"(Ad) is light [energy].\",\"short\":\"light\"},\"cmir\":{\"family\":\"R\",\"long\":\"(Ad) emits/produce [Ed].\",\"short\":\"emits\",\"switch\":true},\"smai\":{\"family\":\"R\",\"long\":\"(Ad) receives/absorbs [Ed].\",\"short\":\"receives\",\"switch\":true},\"flua\":{\"family\":\"R\",\"long\":\"(Ad) is a sound.\",\"short\":\"sound\"},\"fana\":{\"family\":\"R\",\"long\":\"(Ad) is a parent of [Ed].\",\"short\":\"parent\",\"switch\":true,\"tags\":[\"kinship\",\"family\"]},\"kana\":{\"family\":\"R\",\"long\":\"(Ad) is a sibling/brother/sister of [Ed].\",\"short\":\"sibling\",\"switch\":true,\"tags\":[\"kinship\",\"family\"]},\"mana\":{\"family\":\"R\",\"long\":\"(Ad) is a mother of [Ed].\\\\nEquivalent to {sfe fana}.\\\\n\",\"short\":\"mother\",\"switch\":true,\"tags\":[\"kinship\",\"family\"]},\"pana\":{\"family\":\"R\",\"long\":\"(Ad) is a father of [Ed].\\\\nEquivalent to {kla fana}.\\\\n\",\"short\":\"father\",\"switch\":true,\"tags\":[\"kinship\",\"family\"]},\"dzana\":{\"family\":\"R\",\"long\":\"(Ad) is married to [Ed].\",\"short\":\"married\",\"switch\":true,\"tags\":[\"kinship\",\"family\"]},\"kineo\":{\"family\":\"R\",\"long\":\"(Ad) touches [Ed].\",\"short\":\"touches\",\"switch\":true},\"vario\":{\"family\":\"R\",\"long\":\"(Ad) is strange/weird.\",\"short\":\"strange\"},\"zvao\":{\"family\":\"R\",\"long\":\"(A0) is an accident/unintentional.\",\"short\":\"accident\"},\"tera\":{\"family\":\"R\",\"long\":\"(Ad) is a planet in orbit around (Ec) (default: Sun).\",\"short\":\"planet\"},\"sora\":{\"family\":\"R\",\"long\":\"(Ad) is a star.\",\"short\":\"star\"},\"luna\":{\"family\":\"R\",\"long\":\"(Ad) is a major natural satellite/moon in orbit around planet (Ec) (default: Earth).\",\"short\":\"moon\"},\"zoni\":{\"family\":\"R\",\"long\":\"(Ad) pertains to [Ed].\",\"short\":\"pertains\",\"switch\":true},\"kari\":{\"family\":\"R\",\"long\":\"(Ad) has axiomatic belief that [E0] is true.\\\\n[E0] is an axiom, is presupposed to be true and it\\'s truth value is never\\\\nput into doupt.\\\\n\",\"short\":\"axiom\",\"switch\":true},\"menoe\":{\"family\":\"R\",\"long\":\"(Ad) is an apple.\",\"short\":\"apple\"},\"kcaro\":{\"family\":\"R\",\"long\":\"(Ad) is an table.\",\"short\":\"table\"},\"guro\":{\"family\":\"R\",\"long\":\"(Ad) is a country/territory.\",\"short\":\"country\"},\"drai\":{\"family\":\"R\",\"long\":\"(Ad) is a god.\",\"short\":\"god\"},\"e tsen ban\":{\"family\":\"C2\",\"long\":\"(Ad) is a constructed language/conlang.\",\"short\":\"conlang\"},\"e ber ban\":{\"family\":\"C2\",\"long\":\"(Ad) is the eberban language.\",\"short\":\"eberban\",\"tags\":[\"cultural\"]},\"e ujbo ban\":{\"family\":\"C2\",\"long\":\"(Ad) is the lojban language.\",\"short\":\"lojban\",\"tags\":[\"cultural\"]},\"e ufranse ban\":{\"family\":\"C2\",\"long\":\"(Ad) is the french language.\",\"short\":\"french language\",\"tags\":[\"cultural\"]},\"e ufranse guro\":{\"family\":\"C2\",\"long\":\"(Ad) is France.\",\"short\":\"France\",\"tags\":[\"cultural\"]},\"e uinglici ban\":{\"family\":\"C2\",\"long\":\"(Ad) is the english language.\",\"short\":\"english language\",\"tags\":[\"cultural\"]},\"e unihon ban\":{\"family\":\"C2\",\"long\":\"(Ad) is the japanese language.\",\"short\":\"japanese language\",\"tags\":[\"cultural\"]},\"e unihon guro\":{\"family\":\"C2\",\"long\":\"(Ad) is Japan.\",\"short\":\"Japan\",\"tags\":[\"cultural\"]},\"e udjonguo ban\":{\"family\":\"C2\",\"long\":\"(Ad) is chinese language.\",\"short\":\"chinese language\",\"tags\":[\"cultural\"]},\"e udjonguo guro\":{\"family\":\"C2\",\"long\":\"(Ad) is China.\",\"short\":\"China\",\"tags\":[\"cultural\"]},\"e udoitce ban\":{\"family\":\"C2\",\"long\":\"(Ad) is german language.\",\"short\":\"german language\",\"tags\":[\"cultural\"]},\"e udoitce guro\":{\"family\":\"C2\",\"long\":\"(Ad) is Germany.\",\"short\":\"Germany\",\"tags\":[\"cultural\"]},\"e umiser guro\":{\"family\":\"C2\",\"long\":\"(Ad) is Egypt.\",\"short\":\"Egypt\",\"tags\":[\"cultural\"]},\"e uhangu ban\":{\"family\":\"C2\",\"long\":\"(Ad) is korean language.\",\"short\":\"korean language\",\"tags\":[\"cultural\"]},\"e uhangu guro\":{\"family\":\"C2\",\"long\":\"(Ad) is South Korea.\",\"short\":\"South Korea\",\"tags\":[\"cultural\"]},\"e utcoson ban\":{\"family\":\"C2\",\"long\":\"(Ad) is korean language.\",\"short\":\"korean language\",\"tags\":[\"cultural\"]},\"e utcoson guro\":{\"family\":\"C2\",\"long\":\"(Ad) is North Korea.\",\"short\":\"North Korea\",\"tags\":[\"cultural\"]},\"e ta dena\":{\"family\":\"C2\",\"long\":\"(Ad) is a Sunday.\",\"short\":\"Sunday\",\"tags\":[\"time\",\"day\"]},\"e te dena\":{\"family\":\"C2\",\"long\":\"(Ad) is a Monday.\",\"short\":\"Monday\",\"tags\":[\"time\",\"day\"]},\"e to dena\":{\"family\":\"C2\",\"long\":\"(Ad) is a Thusday.\",\"short\":\"Thusday\",\"tags\":[\"time\",\"day\"]},\"e tu dena\":{\"family\":\"C2\",\"long\":\"(Ad) is a Wednesday.\",\"short\":\"Wednesday\",\"tags\":[\"time\",\"day\"]},\"e tia dena\":{\"family\":\"C2\",\"long\":\"(Ad) is a Thursday.\",\"short\":\"Thursday\",\"tags\":[\"time\",\"day\"]},\"e tie dena\":{\"family\":\"C2\",\"long\":\"(Ad) is a Friday.\",\"short\":\"Friday\",\"tags\":[\"time\",\"day\"]},\"e tio dena\":{\"family\":\"C2\",\"long\":\"(Ad) is a Saturday.\",\"short\":\"Saturday\",\"tags\":[\"time\",\"day\"]},\"e tiu dena\":{\"family\":\"C2\",\"long\":\"(Ad) is a Sunday.\",\"short\":\"Sunday\",\"tags\":[\"time\",\"day\"]},\"e ta gare\":{\"family\":\"C2\",\"long\":\"(Ad) is a January.\",\"short\":\"January\",\"tags\":[\"time\",\"month\"]},\"e te gare\":{\"family\":\"C2\",\"long\":\"(Ad) is a February.\",\"short\":\"February\",\"tags\":[\"time\",\"month\"]},\"e to gare\":{\"family\":\"C2\",\"long\":\"(Ad) is a March.\",\"short\":\"March\",\"tags\":[\"time\",\"month\"]},\"e tu gare\":{\"family\":\"C2\",\"long\":\"(Ad) is a April.\",\"short\":\"April\",\"tags\":[\"time\",\"month\"]},\"e tia gare\":{\"family\":\"C2\",\"long\":\"(Ad) is a May.\",\"short\":\"May\",\"tags\":[\"time\",\"month\"]},\"e tie gare\":{\"family\":\"C2\",\"long\":\"(Ad) is a June.\",\"short\":\"June\",\"tags\":[\"time\",\"month\"]},\"e tio gare\":{\"family\":\"C2\",\"long\":\"(Ad) is a July.\",\"short\":\"July\",\"tags\":[\"time\",\"month\"]},\"e tiu gare\":{\"family\":\"C2\",\"long\":\"(Ad) is a August.\",\"short\":\"August\",\"tags\":[\"time\",\"month\"]},\"e tai gare\":{\"family\":\"C2\",\"long\":\"(Ad) is a September.\",\"short\":\"September\",\"tags\":[\"time\",\"month\"]},\"e tei gare\":{\"family\":\"C2\",\"long\":\"(Ad) is a October.\",\"short\":\"October\",\"tags\":[\"time\",\"month\"]},\"e toi gare\":{\"family\":\"C2\",\"long\":\"(Ad) is a November.\",\"short\":\"October\",\"tags\":[\"time\",\"month\"]},\"e tui gare\":{\"family\":\"C2\",\"long\":\"(Ad) is a December.\",\"short\":\"December\",\"tags\":[\"time\",\"month\"]},\"e kre vier\":{\"family\":\"C2\",\"long\":\"(Ad) visits [Ed] with guide (Id).\",\"short\":\"guided visit\",\"switch\":true},\"e tana kano\":{\"family\":\"C2\",\"long\":\"(Ad) is bigger (in volume) than [Ed].\",\"short\":\"bigger (volume)\",\"switch\":true},\"e tana gere\":{\"family\":\"C2\",\"long\":\"(Ad) is smaller (in volume) than [Ed].\",\"short\":\"smaller (volume)\",\"switch\":true},\"e vin zane\":{\"family\":\"C2\",\"long\":\"(Ad) is a writing system with symbols (Ed) and set of rules (Is0).\",\"short\":\"smaller (volume)\"},\"e spi tori\":{\"family\":\"C2\",\"long\":\"(Ad) is a parrot.\",\"short\":\"parrot\",\"tags\":[\"animal\"]},\"e sier vanu\":{\"family\":\"C2\",\"long\":\"(Ad) is an hyperlink to/URL of resource [Ed].\",\"short\":\"hyperlink\"},\"e merue zane\":{\"family\":\"C2\",\"long\":\"(Ac) is an organism with body parts [Ec] forming body (Ic).\",\"short\":\"body\",\"switch\":true},\"e gze slaen\":{\"family\":\"C2\",\"long\":\"(Ad) hangs from [Ed].\",\"short\":\"hang\",\"switch\":true},\"e skao zari\":{\"family\":\"C2\",\"long\":\"(Ad) is a source code of [Ed].\",\"short\":\"source code\",\"switch\":true},\"e curo skien\":{\"family\":\"C2\",\"long\":\"(Ad) is a parser from grammar [Ed].\",\"short\":\"parser\",\"switch\":true},\"e pu zoi\":{\"family\":\"C2\",\"long\":\"(Ad) is a paragraph.\",\"short\":\"paragraph\"},\"e bion cnue\":{\"family\":\"C2\",\"long\":\"(Ad) [ill/sickness] is characterized by symptom [E1].\",\"short\":\"symptom\",\"switch\":true},\"e tor vuno\":{\"family\":\"C2\",\"long\":\"(Ad) is far (large distance) from [Ed].\",\"short\":\"far\",\"switch\":true},\"e ter vuno\":{\"family\":\"C2\",\"long\":\"(Ad) is close (short distance) to [Ed].\",\"short\":\"close\",\"switch\":true},\"e za zoi\":{\"family\":\"C2\",\"long\":\"(Ad) is a name of [Ec].\",\"short\":\"name\",\"switch\":true},\"i len po bu\":{\"family\":\"C3\",\"long\":\"(Ad) is a dictionary.\",\"short\":\"dictionary\"}}');\n\n//# sourceURL=webpack://bundle/../dictionary/en.yaml?");

/***/ }),

/***/ "./src/dictionary.js":
/*!***************************!*\
  !*** ./src/dictionary.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports.words_en = __webpack_require__(/*! ../../dictionary/en.yaml */ \"../dictionary/en.yaml\");\n\n//# sourceURL=webpack://bundle/./src/dictionary.js?");

/***/ }),

/***/ "./src/process_parse_tree.js":
/*!***********************************!*\
  !*** ./src/process_parse_tree.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n * CAMXES.JS POSTPROCESSOR\n * \n * Entry point: camxes_postprocessing(input, mode)\n * \n * Arguments:\n *    • input: [array]  Camxes' parse tree output.\n *          OR [string] JSON stringified parse tree.\n *    • mode:  [string] Parse tree processing option list (each option is\n *                      symbolized by a letter). See below for details.\n *          OR [number] (Deprecated) Older options representation encoded as\n *                      bit flags on a number.\n * \n * Return value:\n *       [string] postprocessed version of camxes' output\n * \n * Details for the `mode´ arguent's values:\n * \n * The mode argument can be any letter string, each letter stands for a specific\n * option. Here is the list of possible letters and their associated meaning:\n *    'J' -> JSON output format\n *    'I' -> Indented JSON output format\n *    'M' -> Keep morphology\n *    'S' -> Show spaces\n *    'T' -> Show terminators\n *    'C' -> Show word classes (selmaho)\n *    'R' -> Raw output, do not trim the parse tree. If this option isn't set,\n *           all the nodes (with the exception of those saved if the 'N' option\n *           is set) are pruned from the tree.\n *    'N' -> Show main node labels\n *    'G' -> Show glosses instead of Lojban\n */\n\n/*\n * Function list:\n *   -- camxes_postprocessing(text, mode)\n *   -- newer_postprocessor(parse_tree, with_morphology, with_spaces,\n *                          with_terminators, with_trimming, with_selmaho,\n *                          with_nodes_labels)\n *   -- process_parse_tree(parse_tree, value_substitution_map,\n *                         name_substitution_map, node_action_for,\n *                         must_prefix_leaf_labels)\n *   -- among(v, s)\n *   -- is_family(v)\n *   -- prettify_brackets(str)\n *   -- str_print_uint(val, charset)\n *   -- str_replace(str, pos, len, sub)\n *   -- is_string(v)\n *   -- is_array(v)\n *   -- is_number(v)\n */\n\n// var glosser = require('../gismudata.js');\n\nif (typeof alert !== 'function') alert = console.log; // For Node.js\n\nconst { is_array, is_family, is_string, is_number } = __webpack_require__(/*! ./util */ \"./src/util.js\");\n\n/*\n * Main function.\n */\nfunction camxes_postprocessing(input, mode) {\n\t/* Checking the input */\n\tif (is_string(input)) input = JSON.parse(input);\n\tif (!is_array(input))\n\t\treturn (\n\t\t\t'Postprocessor error: invalid input type for the first argument. ' +\n\t\t\t'It should be either an array or a JSON stringified array, but ' +\n\t\t\t\"the argument given is of type '\" +\n\t\t\ttypeof input +\n\t\t\t\"'.\"\n\t\t);\n\t/* Reading the options */\n\tif (is_number(mode)) mode = mode_from_number_code(mode);\n\tif (is_string(mode)) {\n\t\tvar with_spaces = among('S', mode);\n\t\tvar with_morphology = among('M', mode);\n\t\tvar with_terminators = among('T', mode);\n\t\tvar with_trimming = !among('R', mode);\n\t\tvar with_selmaho = among('C', mode);\n\t\tvar with_nodes_labels = among('N', mode);\n\t\tvar with_json_format = among('J', mode);\n\t\tvar with_indented_json = among('I', mode);\n\t\tvar without_leaf_prefix = among('!', mode);\n\t\tvar with_glossing = among('G', mode);\n\t} else throw 'camxes_postprocessing(): Invalid mode argument type!';\n\t/* Calling the postprocessor */\n\tvar output = newer_postprocessor(\n\t\tinput,\n\t\twith_morphology,\n\t\twith_spaces,\n\t\twith_terminators,\n\t\twith_trimming,\n\t\twith_selmaho,\n\t\twith_nodes_labels,\n\t\twithout_leaf_prefix,\n\t\twith_glossing\n\t);\n\tif (output === null) output = [];\n\t/* Converting the parse tree into JSON format */\n\toutput = JSON.stringify(output, undefined, with_indented_json ? 2 : 0);\n\tif (with_json_format || with_indented_json) return output;\n\t/* Getting rid of ⟨\"⟩ and ⟨,⟩ characters */\n\toutput = output.replace(/\\\"/gm, '');\n\tif (with_selmaho) output = output.replace(/\\[([a-zA-Z0-9_-]+),\\[/gm, '[$1: [');\n\toutput = output.replace(/,/gm, ' ');\n\t/* Bracket prettification */\n\treturn prettify_brackets(output);\n}\n\n/* Function for translating the legacy option encoding to the new format. */\n/* For backward compatibility. */\nfunction mode_from_number_code(legacy_mode) {\n\tvar mode = '';\n\tif (legacy_mode & 8) mode += 'S';\n\tif (legacy_mode & 16) mode += 'M';\n\tlegacy_mode = legacy_mode % 8;\n\tif (legacy_mode == 0) mode += 'I';\n\tif (legacy_mode == 1) mode += 'J';\n\tif (legacy_mode <= 1) mode += 'R';\n\tif (legacy_mode > 2 && legacy_mode != 5) mode += 'C';\n\tif (legacy_mode == 4 || legacy_mode == 7) mode += 'N';\n\tif (legacy_mode < 5) mode += 'T';\n\treturn mode;\n}\n\n// ========================================================================== //\n\n/*\n * This function adapts the options passed as arguments into a format adapted\n * to the more generalized 'process_parse_tree' function, and then calls this\n * latter.\n */\nfunction newer_postprocessor(\n\tparse_tree,\n\twith_morphology,\n\twith_spaces,\n\twith_terminators,\n\twith_trimming,\n\twith_selmaho,\n\twith_nodes_labels,\n\twithout_leaf_prefix,\n\twith_glossing\n) {\n\tif (!is_array(parse_tree)) return null;\n\t/* Building a map of node names to node value replacements */\n\tif (with_spaces) var value_substitution_map = { spaces: '_', initial_spaces: '_' };\n\telse var value_substitution_map = {};\n\t/* Building a map of node names to name replacements */\n\tvar name_substitution_map = {\n\t\t// \"cmene\": \"C\", \"cmevla\": \"C\", \"gismu\": \"G\", \"lujvo\": \"L\",\n\t\t// \"fuhivla\": \"Z\", \"prenex\": \"PRENEX\", \"sentence\": \"BRIDI\",\n\t\t// \"selbri\": \"SELBRI\", \"sumti\": \"SUMTI\"\n\t\troot: 'R',\n\t\tborrowing_content: 'B'\n\t};\n\n\tif (!with_trimming) name_substitution_map = {};\n\tvar special_selmaho = [ 'particle', 'root', 'borrowing', 'foreign_quote_content' ];\n\t/** Building a node_action_for() function from the selected options **/\n\tif (with_morphology)\n\t\tvar is_flattening_target = function(tree) {\n\t\t\treturn false;\n\t\t};\n\telse\n\t\tvar is_flattening_target = function(tree) {\n\t\t\tvar targets = special_selmaho;\n\t\t\treturn among(tree[0], targets) || is_family(tree[0]);\n\t\t};\n\tvar is_branch_removal_target = function(tree) {\n\t\tif (!with_spaces && among(tree[0], [ 'spaces', 'initial_spaces' ])) return true;\n\t\treturn !with_terminators && is_family(tree[0]) && tree.length == 1;\n\t};\n\tvar whitelist = [];\n\tif (with_selmaho) whitelist = whitelist.concat(special_selmaho);\n\t// if (with_nodes_labels)\n\t//     whitelist = whitelist.concat([\"prenex\", \"sentence\", \"selbri\", \"sumti\"]);\n\tvar is_node_trimming_target = function(tree) {\n\t\tif (!with_trimming) return false;\n\t\tif (with_terminators && is_family(tree[0]) && tree.length == 1) return false;\n\t\tif (with_selmaho && is_family(tree[0])) return false;\n\t\treturn !among(tree[0], whitelist);\n\t};\n\tvar node_action_for = function(node) {\n\t\tif (is_branch_removal_target(node)) return 'DEL';\n\t\tvar ft = is_flattening_target(node);\n\t\tvar tt = is_node_trimming_target(node);\n\t\tif (ft && tt) return 'TRIMFLAT';\n\t\tif (ft) return 'FLAT';\n\t\tif (tt) return 'TRIM';\n\t\tif (with_trimming && node.length == 1) return 'UNBOX';\n\t\treturn 'PASS';\n\t};\n\t/* Calling process_parse_tree() with the arguments we've built for it */\n\treturn process_parse_tree(\n\t\tparse_tree,\n\t\tvalue_substitution_map,\n\t\tname_substitution_map,\n\t\tnode_action_for,\n\t\t(with_nodes_labels || with_selmaho) && !without_leaf_prefix,\n\t\twith_glossing\n\t);\n}\n\n/*\n * Recursive function for editing a parse tree. Performs a broad range of\n * editions depending on the given arguments. Returns the edited parse tree.\n * \n * • value_substitution_map [Map]:\n *     A map of node names to node value replacements. Used to override the\n *     content of specific leaf nodes.\n * • name_substitution_map [Map]:\n *     A map of node names to node name replacements. Used to rename specific\n *     nodes.\n * • node_action_for [Function: Array -> String]:\n *     A function for deriving the appropriate edition action for the argument\n *     parse tree node; returns an action name, whose possible values are:\n *     • 'DEL':  Triggers deletion of the current tree branch.\n *     • 'TRIM': Triggers pruning of the current node; the node name is erased\n *               and if it has only one child node, this child node replaces it.\n *     • 'FLAT': Triggers flattening of the current tree branch; all its\n *               terminal leaves values are concatenated and the concatenation\n *               results replaces the content of the branch.\n *     • 'TRIMFLAT': Same as 'FLAT' but also removes the current node.\n *     • 'UNBOX':    If the current node contains only one element, this element\n *                   replaces the current node.\n *     • 'PASS':     Does nothing.\n * • must_prefix_leaf_labels [Boolean]:\n *     If true, remaining node names get a colon appended to them, and if they\n *     contain a single leaf value, they get concatenated with their value, and\n *     the concatenation result would replace the node itself.\n *     For example, a terminal node [\"UI\",\"ui\"] would become \"UI:ui\" (note that\n *     the brackets disappeared).\n */\nfunction process_parse_tree(\n\tparse_tree,\n\tvalue_substitution_map,\n\tname_substitution_map,\n\tnode_action_for,\n\tmust_prefix_leaf_labels,\n\twith_glossing\n) {\n\tif (parse_tree.length == 0) return null;\n\tvar action = node_action_for(parse_tree);\n\tif (action == 'DEL') return null; // Deleting the current branch.\n\tvar has_name = is_string(parse_tree[0]);\n\t// Getting the value replacement for this node, if any.\n\tvar substitution_value = has_name ? value_substitution_map[parse_tree[0]] : undefined;\n\tif (has_name) {\n\t\tif (action == 'TRIM') {\n\t\t\t/* If there's a value replacement for this node, we return it\n               instead of the node's content. */\n\t\t\tif (typeof substitution_value !== 'undefined') return substitution_value;\n\t\t\t/* Otherwise the first step of a trim action is to remove the node\n               name. */\n\t\t\tparse_tree.splice(0, 1);\n\t\t\thas_name = false;\n\t\t} else {\n\t\t\t/* No trimming, so let's see if the node name is in the renaming\n               list. If so, let's rename it accordingly. */\n\t\t\tvar v = name_substitution_map[parse_tree[0]];\n\t\t\tif (typeof v !== 'undefined') parse_tree[0] = v;\n\t\t\t/* If there's a value replacement for this node, it becomes the\n               unique value for the node. */\n\t\t\tif (typeof substitution_value !== 'undefined') return [ parse_tree[0], substitution_value ];\n\t\t}\n\t}\n\tif (action == 'FLAT') {\n\t\t/* Flattening action. All the terminal nodes of the branch are\n           concatenated, and the concatenation result replaces the branch's\n           content, alongside the node name if any. If the concatenation\n           result is empty, the branch becomes empty. */\n\t\tvar r = join_expr(parse_tree);\n\t\tif (has_name && r != '') {\n\t\t\tif (must_prefix_leaf_labels) return parse_tree[0] + ':' + r;\n\t\t\telse return [ parse_tree[0], r ];\n\t\t} else if (has_name) return parse_tree[0];\n\t\telse return r;\n\t} else if (action == 'TRIMFLAT') return join_expr(parse_tree);\n\t/* Now we'll iterate over all the other elements of the current node. */\n\tvar i = has_name ? 1 : 0;\n\twhile (i < parse_tree.length) {\n\t\tif (is_array(parse_tree[i])) {\n\t\t\t/* Recursion */\n\t\t\tparse_tree[i] = process_parse_tree(\n\t\t\t\tparse_tree[i],\n\t\t\t\tvalue_substitution_map,\n\t\t\t\tname_substitution_map,\n\t\t\t\tnode_action_for,\n\t\t\t\tmust_prefix_leaf_labels,\n\t\t\t\twith_glossing\n\t\t\t);\n\t\t}\n\t\t/* The recursion call on the current element might have set it to null\n           as a request for deletion. */\n\t\tif (parse_tree[i] === null) parse_tree.splice(i, 1);\n\t\telse i++; // No deletion, so let's go to the next element.\n\t}\n\t/* Now we've finished iterating over the node elements. Let's proceed to\n       the final steps. */\n\t/* If 'must_prefix_leaf_labels' is set and the node has a name and contains\n       at least one other element, we append ':' to its name. */\n\t//    if (has_name && parse_tree.length >= 2 && must_prefix_leaf_labels) {\n\t//        parse_tree[0] += ':';\n\t//    }\n\t/* If the node is empty, we return null as a signal for deletion. */\n\tif (i == 0) return null;\n\telse if (i == 1 && action != 'PASS') {\n\t\t/* If the node contains only one element and we want to trim the node,\n       it gets replaced by its content. */\n\n\t\t// if (with_glossing && glosser.words[parse_tree[0]]) {\n\t\t// \tparse_tree[0] = \"'\" + glosser.words[parse_tree[0]].short + \"'\";\n\t\t// }\n\t\treturn parse_tree[0];\n\t} else if (must_prefix_leaf_labels && i == 2 && has_name && is_string(parse_tree[1])) {\n\t\t/* If 'must_prefix_leaf_labels' is set and the node is a pair of string,\n       we return the concatenation of both strings separated with a colon. */\n\t\tif (!parse_tree[1].includes(':')) return parse_tree[0] + ':' + parse_tree[1];\n\t\telse parse_tree[0] += ':';\n\t}\n\treturn parse_tree;\n}\n\n// ========================================================================== //\n\n/* This function returns the string resulting from the recursive concatenation\n * of all the leaf elements of the parse tree argument (except node names). */\n// \"join_leaves\" or \"flatten_tree\" might be better names.\nfunction join_expr(n) {\n\tif (n.length < 1) return '';\n\tvar s = '';\n\tvar i = is_array(n[0]) ? 0 : 1;\n\twhile (i < n.length) {\n\t\ts += is_string(n[i]) ? n[i] : join_expr(n[i]);\n\t\ti++;\n\t}\n\treturn s;\n}\n\nfunction among(v, s) {\n\tvar i = 0;\n\twhile (i < s.length) if (s[i++] == v) return true;\n\treturn false;\n}\n\n// function is_family(v) {\n// \tif (!is_string(v)) return false;\n// \t// return v.startsWith(\"p_\");\n// \treturn 0 == v.search(/^[BCDFGJKLMNPRSTVXZ]?([AEIOUQH])+$/g);\n// }\n\n// ========================================================================== //\n\n/*\n * Bracket prettification for textual rendering of parse trees.\n */\nfunction prettify_brackets(str) {\n\tvar open_brackets = [ '(', '[', '{', '<' ];\n\tvar close_brackets = [ ')', ']', '}', '>' ];\n\tvar brackets_number = 4;\n\t//\tvar numset = ['0','1','2','3','4','5','6','7','8','9'];\n\tvar numset = [ '\\u2070', '\\u00b9', '\\u00b2', '\\u00b3', '\\u2074', '\\u2075', '\\u2076', '\\u2077', '\\u2078', '\\u2079' ];\n\tvar i = 0;\n\tvar floor = 0;\n\twhile (i < str.length) {\n\t\tif (str[i] == '[') {\n\t\t\tvar n = floor % brackets_number;\n\t\t\tvar num = floor && !n ? str_print_uint(floor / brackets_number, numset) : '';\n\t\t\tstr = str_replace(str, i, 1, open_brackets[n] + num);\n\t\t\tfloor++;\n\t\t} else if (str[i] == ']') {\n\t\t\tfloor--;\n\t\t\tvar n = floor % brackets_number;\n\t\t\tvar num = floor && !n ? str_print_uint(floor / brackets_number, numset) : '';\n\t\t\tstr = str_replace(str, i, 1, num + close_brackets[n]);\n\t\t}\n\t\ti++;\n\t}\n\treturn str;\n}\n\n/* ================== */\n/* ===  Routines  === */\n/* ================== */\n\nfunction str_print_uint(val, charset) {\n\t// 'charset' must be a character array.\n\tvar radix = charset.length;\n\tvar str = '';\n\tval -= val % 1; // No float allowed\n\twhile (val >= 1) {\n\t\tstr = charset[val % radix] + str;\n\t\tval /= radix;\n\t\tval -= val % 1;\n\t}\n\treturn str;\n}\n\nfunction str_replace(str, pos, len, sub) {\n\tif (pos < str.length) {\n\t\tif (pos + len >= str.length) len -= pos + len - str.length;\n\t\treturn str.substring(0, pos) + sub + str.substring(pos + len);\n\t} else return str;\n}\n\nmodule.exports.postprocessing = camxes_postprocessing;\nmodule.exports.postprocess = camxes_postprocessing; // Alias\nmodule.exports.process_parse_tree = process_parse_tree;\nmodule.exports.prettify_brackets = prettify_brackets;\n\n//# sourceURL=webpack://bundle/./src/process_parse_tree.js?");

/***/ }),

/***/ "./src/simplify_tree.js":
/*!******************************!*\
  !*** ./src/simplify_tree.js ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { is_string } = __webpack_require__(/*! ./util */ \"./src/util.js\");\n\n// List of important types in eberban that we want to show up in the simplified\n// tree.\nconst important_types = [\n\t// text\n\t[ 'text', 'text' ],\n\t[ 'paragraph', 'paragraph' ],\n\t[ 'definition', 'definition' ],\n\t[ 'sentence', 'sentence' ],\n\n\t// scope\t\n\t[ 'scope', 'scope' ],\n\t[ 'scope_list', 'list' ],\n\t[ 'scope_list_element', 'list element' ],\n\t[ 'chaining', 'chaining' ],\n\t[ 'chaining_neg', 'chaining negation' ],\n\t[ 'chaining_unit', 'chaining unit' ],\n\t[ 'va_scope', 'VA-scope' ],\n\t[ 'va_scope_first', 'explicit switch' ],\n\t[ 'va_scope_next', 'explicit switch' ],\n\t[ 'arguments_list', 'arguments' ],\n\t[ 'definition_key', 'defined predicate'],\n\n\t// predicates\n\t[ 'predicate', 'predicate' ],\n\t[ 'compound', 'compound' ],\n\t[ 'borrowing_group', 'borrowing group' ],\n\t[ 'borrowing', 'borrowing' ],\n\t[ 'foreign_word', 'foreign' ],\n\t[ 'grammatical_quote', 'quote' ],\n\t[ 'one_word_quote', 'word quote' ],\n\t[ 'foreign_quote', 'foreign quote' ],\n\t[ 'unit_number', 'number' ],\n\t[ 'predicate_scope', 'predicate scope' ],\n\n\t// free\n\t[ 'free_prefix', 'prefix' ],\n\t[ 'free_parenthetical', 'parenthetical' ],\n\t[ 'free_subscript', 'subscript' ],\n\t[ 'free_override', 'override' ],\n];\n\n// List of simplifying functions.\nvar simplifyFunctions = {};\n\n// Fills the simplify functions list with important types.\nfor (let replace of important_types) {\n\tsimplifyFunctions[replace[0]] = function(parse) {\n\t\treturn {\n\t\t\ttype: replace[1],\n\t\t\tchildren: simplifyArrayOfTrees(parse.slice(1))\n\t\t};\n\t};\n}\n\n/**\n * This file contains functions that simplify the parse tree returned by camxes.js.\n * \n * The original parse tree has the following structure:\n * [\n *   \"...\",   // the type\n *   ...      // children as array elements\n * ]\n * Here, the first element of every array indicates the type of the object parsed, and the\n * next objects are the children of the element.\n * \n * The simplified parse tree has quite another structure:\n * [\n *   {\n *     type: \"...\",\n *     children: [ ... ],   // only one of children and word\n *     word: \"...\",\n *     ...: ...             // other optional elements\n *   }\n * ]\n * Here, type gives the type. For non-terminals, children is an array containing the children.\n * For terminals, word contains the actual word parsed. (Of course, one cannot have both\n * children and word.) Furthermore, there can be more elements added to this structure to add\n * additional information as needed.\n */\n\n/**\n * Simplifies the given parse tree. Returns an array.\n */\nfunction simplifyTree(parse) {\n\t// if it is a terminal, just return that\n\tif (parse.length == 2 && is_string(parse[0]) && is_string(parse[1])) {\n\t\treturn [\n\t\t\t{\n\t\t\t\ttype: parse[0],\n\t\t\t\tword: parse[1]\n\t\t\t}\n\t\t];\n\t}\n\n\tvar f = simplifyFunctions[parse[0]];\n\n\t// if there is a simplification function, apply it\n\tif (f) {\n\t\treturn [ f(parse) ];\n\t}\n\n\t// else, we recursively search the children for things we do have a simplification function for\n\tvar result;\n\tif (is_string(parse[0])) {\n\t\tresult = simplifyArrayOfTrees(parse.slice(1));\n\t} else {\n\t\tresult = simplifyArrayOfTrees(parse);\n\t}\n\n\treturn result;\n}\n\n/**\n * Simplifies an array of trees.\n */\nfunction simplifyArrayOfTrees(parse) {\n\tvar result = [];\n\n\tfor (var i in parse) {\n\t\tresult = result.concat(simplifyTree(parse[i]));\n\t}\n\n\treturn result;\n}\n\nmodule.exports.simplifyTree = simplifyTree;\n\n//# sourceURL=webpack://bundle/./src/simplify_tree.js?");

/***/ }),

/***/ "./src/util.js":
/*!*********************!*\
  !*** ./src/util.js ***!
  \*********************/
/***/ ((module) => {

eval("function remove_spaces(tree) {\n    if (tree.length > 0 && among(tree[0], [\"spaces\", \"initial_spaces\"])) return null;\n    var i = 0;\n    while (i < tree.length) {\n        if (is_array(tree[i])) {\n            tree[i] = remove_spaces(tree[i]);\n            if (tree[i] === null) tree.splice(i--, 1);\n        }\n        i++;\n    }\n    return tree;\n}\n/*\n * EXAMPLE OF PARSE TREE PRUNING PROCEDURE\n * \n * remove_morphology(parse_tree)\n * \n * This function takes a parse tree, and joins the expressions of the following\n * nodes:\n * \"cmevla\", \"gismu_2\", \"lujvo\", \"fuhivla\", \"spaces\"\n * as well as any selmaho node (e.g. \"KOhA\").\n * \n */\n\nfunction remove_morphology(pt) {\n    if (pt.length < 1) return [];\n    var i;\n    /* Sometimes nodes have no label and have instead an array as their first\n       element. */\n    if (is_array(pt[0])) i = 0;\n    else { // The first element is a label (node name).\n        // Let's check if this node is a candidate for our pruning.\n        if (is_target_node(pt)) {\n            /* We join recursively all the terminal elements (letters) in this\n             * node and its child nodes, and put the resulting string in the #1\n             * slot of the array; afterwards we delete all the remaining elements\n             * (their terminal values have been concatenated into pt[1]). */\n            pt[1] = join_expr(pt);\n            // If pt[1] contains an empty string, let's delete it as well:\n            pt.splice((pt[1] == \"\") ? 1 : 2);\n            return pt;\n        }\n        i = 1;\n    }\n    /* If we've reached here, then this node is not a target for pruning, so let's\n       do recursion into its child nodes. */\n    while (i < pt.length) {\n        if (is_array(pt[i])) remove_morphology(pt[i]);\n        i++;\n    }\n    return pt;\n}\n\n/* This function returns the string resulting from the recursive concatenation of\n * all the leaf elements of the parse tree argument (except node names). */\nfunction join_expr(n) {\n    if (n.length < 1) return \"\";\n    var s = \"\";\n    var i = is_array(n[0]) ? 0 : 1;\n    while (i < n.length) {\n        s += is_string(n[i]) ? n[i] : join_expr(n[i]);\n        i++;\n    }\n    return s;\n}\n\n/* Checks whether the argument node is a target for pruning. */\nfunction is_target_node(n) {\n    return (among(n[0], [\"particle\", \"root\", \"borrowing\"])\n            || is_family(n[0]));\n}\n\nfunction among(v, s) {\n    var i = 0;\n    while (i < s.length) if (s[i++] == v) return true;\n    return false;\n}\n\nfunction is_family(v) {\n    if (!is_string(v)) return false;\n    return 0 == v.search(/^[BCDFGJKLMNPRSTVXZ]?([AEIOUH])+$/g);\n}\n\nfunction is_string(v) {\n    return Object.prototype.toString.call(v) === '[object String]';\n}\n\nfunction is_array(v) {\n    return Object.prototype.toString.call(v) === '[object Array]';\n}\n\nfunction is_number(v) {\n\treturn Object.prototype.toString.call(v) === '[object Number]';\n}\n\nmodule.exports.remove_spaces = remove_spaces;\nmodule.exports.remove_morphology = remove_morphology;\nmodule.exports.join_expr = join_expr;\nmodule.exports.is_target_node = is_target_node;\nmodule.exports.among = among;\nmodule.exports.is_family = is_family;\nmodule.exports.is_string = is_string;\nmodule.exports.is_array = is_array;\nmodule.exports.is_number = is_number;\n\n\n//# sourceURL=webpack://bundle/./src/util.js?");

/***/ }),

/***/ "./webpack/parser.js":
/*!***************************!*\
  !*** ./webpack/parser.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"camxes\": () => (/* binding */ camxes),\n/* harmony export */   \"postprocessing\": () => (/* binding */ postprocessing),\n/* harmony export */   \"parse\": () => (/* binding */ parse)\n/* harmony export */ });\nconst { camxes } = __webpack_require__(/*! ../grammar/eberban */ \"./grammar/eberban.js\");\nconst { remove_morphology, remove_spaces } = __webpack_require__(/*! ../src/util */ \"./src/util.js\");\nconst { simplifyTree } = __webpack_require__(/*! ../src/simplify_tree */ \"./src/simplify_tree.js\");\nconst { postprocessing } = __webpack_require__(/*! ../src/process_parse_tree */ \"./src/process_parse_tree.js\");\n\nconst { words_en: words } = __webpack_require__(/*! ../src/dictionary */ \"./src/dictionary.js\");\n\nconst hideTitleList = [\n\t'paragraph',\n\t'sentence',\n\t'definition',\n\t'scope',\n\t'list element',\n\t'predicate',\n\t'chaining unit',\n\t'chaining negation',\n\t'VA-scope',\n\t'borrowing group',\n];\n\nconst hideFamily = [\n\t'a',\n\t'e',\n\t'i',\n\t'o',\n\t'u',\n\t'foreign_word',\n\t'foreign_quote_word',\n]\n\n// List of types with their associated CSS classes.\nconst boxClassForTypeMap = new Map([\n\t// text\n\t[ 'paragraph', 'box box-paragraph' ],\n\t[ 'sentence', 'box box-sentence' ],\n\t[ 'definition', 'box box-sentence' ],\n\t[ 'arguments', 'box box-arguments' ],\n\t[ 'defined predicate', 'box box-arguments' ],\n\n\t// scope\n\t[ 'scope', 'box box-scope' ],\n\t[ 'list element', 'box box-scope-highlight' ],\n\t[ 'chaining unit', 'box box-chaining-unit' ],\n\t[ 'chaining negation', 'box box-chaining-neg' ],\n\t[ 'VA-scope', 'box box-va-scope' ],\n\n\t// units\n\t[ 'predicate', 'box box-predicate' ],\n\t[ 'quote', 'box box-predicate' ],\n\t[ 'word quote', 'box box-predicate' ],\n\t[ 'foreign quote', 'box box-predicate' ],\n\t[ 'compound', 'box box-compound' ],\n\t[ 'number', 'box box-number' ],\n\t[ 'letters', 'box box-letters' ],\n\t[ 'subscope', 'box box-subscope' ],\n\t[ 'borrowing group', 'box box-borrowing' ],\n\t[ 'foreign quote', 'box box-borrowing' ],\n\n\t// free\n\t[ 'indicator', 'box box-note' ],\n\t[ 'discursive', 'box box-note' ],\n\t[ 'subscript', 'box box-note' ],\n\t[ 'parenthetical', 'box box-note' ]\n]);\n\nfunction boxClassForType(parse) {\n\tlet boxClass = boxClassForTypeMap.get(parse.type);\n\treturn boxClass || 'box box-not-shown';\n}\n\nfunction escapeHtml(str) {\n\tvar p = document.createElement('p');\n\tp.appendChild(document.createTextNode(str));\n\treturn p.innerHTML;\n}\n\n/**\n * Launches the parsing process by calling the parser with the data entered in the interface,\n * and processing the results.\n */\nfunction parse() {\n\tvar textToParse = $('#input_textarea').val();\n\t$('#result-row').slideDown();\n\ttry {\n\t\tvar start = new Date().getTime();\n\t\ttextToParse = ' ' + textToParse; // add initial space to help parser\n\t\tvar parse = camxes.parse(textToParse);\n\t\tvar end = new Date().getTime();\n\t\t$('#time-label').html('(parsing took ' + (end - start) + ' ms)');\n\t\tparse = remove_morphology(parse);\n\t\tparse = remove_spaces(parse);\n\t\tvar simplified = simplifyTree(parse);\n\n\t\tif (parse) {\n\t\t\tvar tokens = [];\n\t\t\tfindTokens(parse, tokens);\n\n\t\t\t// var $parseResultHighlighted = $('#parse-result-highlighted');\n\t\t\t// showHighlighting(simplified[0], tokens, $parseResultHighlighted);\n\n\t\t\tvar $parseResultRaw = $('#parse-result-raw');\n\t\t\tshowRawTree(parse, $parseResultRaw);\n\n\t\t\tvar $parseResultTree = $('#parse-result-tree');\n\t\t\tshowParseTree(parse, $parseResultTree);\n\n\t\t\tvar $parseResultSimplified = $('#parse-result-simplified');\n\t\t\tshowSimplifiedTree(simplified, $parseResultSimplified);\n\n\t\t\tvar $parseResultBoxes = $('#parse-result-boxes');\n\t\t\tshowBoxes(simplified, $parseResultBoxes);\n\n\t\t\tvar $parseResultGlossing = $('#parse-result-glossing');\n\t\t\tshowGlossing(tokens, $parseResultGlossing);\n\t\t}\n\t\t// $('#parse-result-highlighted-tab').html('Highlighted');\n\t\t$('#parse-result-tree-tab').html('Parse tree');\n\t\t$('#parse-result-raw-tab').html('Raw tree');\n\t\t$('#parse-result-simplified-tab').html('Simplified tree');\n\t\t$('#parse-result-boxes-tab').html('Boxes');\n\t\t$('#parse-result-glossing-tab').html('Glosses');\n\t} catch (e) {\n\t\tif (e.name && e.name === 'SyntaxError') {\n\t\t\t// $('#parse-result-highlighted-tab').html('<span class=\"muted\">Highlighted</span>');\n\t\t\t// showSyntaxError(e, textToParse, $('#parse-result-highlighted'));\n\t\t\t$('#parse-result-raw-tab').html('<span class=\"muted\">Raw tree</span>');\n\t\t\tshowSyntaxError(e, textToParse, $('#parse-result-raw'));\n\t\t\t$('#parse-result-simplified-tab').html('<span class=\"muted\">Simplified tree</span>');\n\t\t\tshowSyntaxError(e, textToParse, $('#parse-result-simplified'));\n\t\t\t$('#parse-result-tree-tab').html('<span class=\"muted\">Parse tree</span>');\n\t\t\tshowSyntaxError(e, textToParse, $('#parse-result-tree'));\n\t\t\t$('#parse-result-boxes-tab').html('<span class=\"muted\">Boxes</span>');\n\t\t\tshowSyntaxError(e, textToParse, $('#parse-result-boxes'));\n\t\t\t$('#parse-result-glossing-tab').html('<span class=\"muted\">Glosses</span>');\n\t\t\tshowSyntaxError(e, textToParse, $('#parse-result-glossing'));\n\t\t} else {\n\t\t\tthrow e;\n\t\t}\n\t}\n}\n\n/**\n * Finds all tokens in the resulting parse tree, and puts them in the tokens array.\n */\nfunction findTokens(parse, tokens) {\n\tif (parse instanceof Array) {\n\t\tif (parse.length == 2 && isString(parse[0]) && isString(parse[1])) {\n\t\t\ttokens.push(parse[1]);\n\t\t} else {\n\t\t\tfor (var child in parse) {\n\t\t\t\tfindTokens(parse[child], tokens);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Shows the parse result in the interface.\n */\nfunction showRawTree(parse, $element) {\n\t$element.html('<pre>' + JSON.stringify(parse, undefined, 2) + '</pre>');\n}\n\n/**\n * Shows the parse result in the interface.\n */\nfunction showParseTree(parse, $element) {\n\t$element.html(constructParseTreeOutput(parse, 0));\n}\n\nfunction constructParseTreeOutput(parse, depth) {\n\t// precaution against infinite recursion; this should not actually happen of course\n\tif (depth > 50) {\n\t\treturn '<b>too much recursion :-(</b>';\n\t}\n\n\t// if we get null, just print that\n\tif (parse === null) {\n\t\treturn '<i>(none?)</i>';\n\t}\n\n\t// if we get undefined, just print that\n\tif (!parse) {\n\t\treturn '<i>(undefined?)</i>';\n\t}\n\n\tif (parse instanceof Array) {\n\t\tif (parse.length == 0) {\n\t\t\treturn '<i>(empty array?)</i>';\n\t\t}\n\n\t\tvar output = '';\n\n\t\t// what is the type of parse[0]?\n\t\tif (isString(parse[0])) {\n\t\t\t// it is the type\n\t\t\toutput += parse[0] + ':';\n\n\t\t\tif (isString(parse[1])) {\n\t\t\t\t// a literal\n\t\t\t\toutput += ' <b>[' + parse[1] + ']</b>';\n\t\t\t\tif (words[parse[1]]) {\n\t\t\t\t\toutput += ' <span class=\"translation\">' + words[parse[1]].short + '</span>';\n\t\t\t\t}\n\t\t\t\treturn output;\n\t\t\t}\n\n\t\t\toutput += '<ul>';\n\t\t\tfor (var child in parse) {\n\t\t\t\tif (child !== '0') {\n\t\t\t\t\toutput += '<li>' + constructParseTreeOutput(parse[child], depth + 1) + '</li>';\n\t\t\t\t}\n\t\t\t}\n\t\t\toutput += '</ul>';\n\t\t\treturn output;\n\t\t} else {\n\t\t\toutput += '<i>a list:</i>';\n\t\t\toutput += '<ol>';\n\t\t\tfor (var child in parse) {\n\t\t\t\toutput += '<li>' + constructParseTreeOutput(parse[child], depth + 1) + '</li>';\n\t\t\t}\n\t\t\toutput += '</ol>';\n\t\t\treturn output;\n\t\t}\n\t}\n\n\treturn '<i>(huh? ' + parse + ')</i>';\n}\n\n/**\n * Shows the simplified parse tree in the interface.\n */\nfunction showSimplifiedTree(simplified, $element) {\n\t$element.html(constructSimplifiedTreeOutput(simplified[0], 0));\n}\n\nfunction constructSimplifiedTreeOutput(parse, depth) {\n\t// precaution against infinite recursion; this should not actually happen of course\n\tif (depth > 50) {\n\t\treturn '<b>too much recursion :-(</b>';\n\t}\n\n\t// if we get null, just print that\n\tif (parse === null) {\n\t\treturn '<i>(none?)</i>';\n\t}\n\n\t// if we get undefined, just print that\n\tif (!parse) {\n\t\treturn '<i>(undefined?)</i>';\n\t}\n\n\tvar output = parse.type;\n\tif (parse.sumtiPlace) {\n\t\toutput += parse.sumtiPlace;\n\t}\n\n\tif (parse.word) {\n\t\t// we have a terminal\n\t\toutput += ' <b>[' + parse.word + ']</b>';\n\t\tif (words[parse.word]) {\n\t\t\toutput += ' <span class=\"translation\">' + words[parse.word].short + '</span>';\n\t\t}\n\t} else {\n\t\t// we have a non-terminal\n\n\t\toutput += '<ul>';\n\n\t\tfor (var child in parse.children) {\n\t\t\toutput += '<li>';\n\t\t\toutput += constructSimplifiedTreeOutput(parse.children[child], depth + 1);\n\t\t\toutput += '</li>';\n\t\t}\n\n\t\toutput += '</ul>';\n\t}\n\n\treturn output;\n}\n\n/**\n * Shows the boxes in the interface.\n */\nfunction showBoxes(simplified, $element) {\n\tvar output = '';\n\n\toutput += constructBoxesOutput(simplified[0], 0);\n\n\t/*output += \"<p>Legend: \";\n\tvar types = [\"sentence\", \"prenex\", \"selbri\", \"sumti\"];\n\tfor (var type in types) {\n\t\toutput += \"<div class=\\\"\" + boxClassForType({ type: types[type] }) + \"\\\">\" + types[type] + \"</div>\";\n\t}\n\toutput += \"</p>\";*/\n\n\t$element.html(output);\n}\n\nfunction constructBoxesOutput(parse, depth) {\n\t// precaution against infinite recursion; this should not actually happen of course\n\tif (depth > 50) {\n\t\treturn '<b>too much recursion :-(</b>';\n\t}\n\n\t// if we get null, just print that\n\tif (parse === null) {\n\t\treturn '<i>(none?)</i>';\n\t}\n\n\t// if we get undefined, just print that\n\tif (!parse) {\n\t\treturn '<i>(undefined?)</i>';\n\t}\n\n\tvar output = '';\n\n\tif (parse.word) {\n\t\toutput += '<div class=\"box box-terminal\">';\n\n\t\t// we have a terminal\n\t\toutput += '&nbsp;<div class=\"tip\">' + parse.word;\n\n\t\tif (hideFamily.includes(parse.type)) {\n\t\t// if (parse.type === 'foreign_word' || parse.type === 'foreign_quote_word') {\n\t\t\toutput += '</div>&nbsp;<br></div>';\n\t\t\treturn output;\n\t\t}\n\n\t\tif (words[parse.word] && words[parse.word].long) {\n\t\t\toutput += '<div class=\"tiptext\">' + escapeHtml(words[parse.word].long) + '</div>';\n\t\t}\n\n\t\toutput += '</div>&nbsp;<br>&nbsp;' + parse.type + '&nbsp;<br>';\n\t\t// escapeHtml(words[text[j]].long)\n\n\t\tif (words[parse.word]) {\n\t\t\tlet short = words[parse.word].short;\n\t\t\tif (short) {\n\t\t\t\toutput += '<span class=\"translation\">&nbsp;' + escapeHtml(short) + '&nbsp;</span>';\n\t\t\t}\n\t\t} else if (['KA', 'GA', 'borrowing'].includes(parse.type)) {\n\t\t\toutput += '';\n\t\t} else {\n\t\t\toutput += '...';\n\t\t}\n\n\t\toutput += '</div>';\n\t} else {\n\t\t// we have a non-terminal\n\n\t\toutput += '<div class=\"' + boxClassForType(parse) + '\">';\n\n\t\tfor (var child in parse.children) {\n\t\t\toutput += constructBoxesOutput(parse.children[child], depth + 1);\n\t\t}\n\n\t\tif (boxClassForType(parse) !== 'box box-not-shown') {\n\t\t\tif (!hideTitleList.includes(parse.type)) {\n\t\t\t\tif (parse.type === 'compound') {\n\t\t\t\t\tlet compound_text = [];\n\t\t\t\t\tlet compound = '';\n\n\t\t\t\t\tfor (var child in parse.children) {\n\t\t\t\t\t\tif (parse.children[child].word) {\n\t\t\t\t\t\t\tcompound_text.push(parse.children[child].word);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (compound_text[0] == 'a') {\n\t\t\t\t\t\tcompound = 'a' + extractCanonicalCompound(compound_text, 1, -1).compound;\n\t\t\t\t\t} else if (compound_text[0] == 'e') {\n\t\t\t\t\t\tcompound += 'e' + extractCanonicalCompound(compound_text, 1, 2).compound;\n\t\t\t\t\t} else if (compound_text[0] == 'i') {\n\t\t\t\t\t\tcompound += 'i' + extractCanonicalCompound(compound_text, 1, 3).compound;\n\t\t\t\t\t} else if (compound_text[0] == 'o') {\n\t\t\t\t\t\tcompound += 'o' + extractCanonicalCompound(compound_text, 1, 4).compound;\n\t\t\t\t\t}\n\n\t\t\t\t\toutput += '<br><b>' + compound + '</b>';\n\n\t\t\t\t\tif (words[compound]) {\n\t\t\t\t\t\toutput += ' = <div class=\"tip translation\">' + words[compound].short;\n\n\t\t\t\t\t\tif (words[compound].long) {\n\t\t\t\t\t\t\toutput += '<div class=\"tiptext\">' + escapeHtml(words[compound].long) + '</div>';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\toutput += '&nbsp;</div>';\n\t\t\t\t\t} else {\n\t\t\t\t\t\toutput += ' = <div class=\"tip translation\">???</div>';\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\toutput += '<br>' + parse.type;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\toutput += '</div>';\n\t}\n\n\treturn output;\n}\n\n/**\n * Shows a syntax error in the interface.\n */\nfunction showSyntaxError(e, textToParse, $element) {\n\tvar output =\n\t\t'<div class=\"alert\">' +\n\t\t'<p><b>Syntax error</b> on line <b>' +\n\t\te.line +\n\t\t'</b>, at column <b>' +\n\t\te.column +\n\t\t'</b>: ' +\n\t\te.message +\n\t\t'</p>' +\n\t\t'<p class=\"error-sentence\">' +\n\t\tgenerateErrorPosition(e, textToParse) +\n\t\t'</p>' +\n\t\tgenerateFixes(e) +\n\t\t'</div>';\n\n\t$element.html(output);\n}\n\n/**\n * Generates the text sample that shows the error position.\n */\nfunction generateErrorPosition(e, textToParse) {\n\t//\"mi vau <span class=\\\"error-marker\\\">&#9652;</span> do cusku ...\" +\n\n\tvar before = textToParse.substring(e.offset - 20, e.offset);\n\n\tvar after = textToParse.substring(e.offset + 0, e.offset + 20);\n\n\tif (e.offset > 20) {\n\t\tbefore = '...' + before;\n\t}\n\tif (e.offset < textToParse.length - 20) {\n\t\tafter = after + '...';\n\t}\n\n\treturn before + '<span class=\"error-marker\">&#9652;</span>' + after;\n}\n\nfunction generateFixes(e) {\n\tif (!e.fix) {\n\t\t//return \"<p><i>No quick fixes available.</i></p>\";\n\t\treturn '';\n\t}\n\n\tvar fixes = '<p>Quick fixes:<ul>';\n\n\tfor (var f in e.fix) {\n\t\tvar fix = e.fix[f];\n\t\tfixes += '<li>';\n\n\t\tif (fix.fixFunction) {\n\t\t\tfixes += '<a>';\n\t\t\tfixes += fix.name;\n\t\t\tfixes += '</a>';\n\t\t} else {\n\t\t\tfixes += fix.name;\n\t\t}\n\n\t\tfixes += '</li>';\n\t}\n\n\tfixes += '</ul></p>';\n\n\treturn fixes;\n}\n\n/**\n * Shows the highlighting in the interface.\n */\nfunction showHighlighting(simplified, tokens, $element) {\n\tvar output = '';\n\n\tvar mode = 1;\n\tvar classString = 'latin-highlighting';\n\n\t// if ($('#latin-button').hasClass('active')) {\n\t// \tvar mode = 1;\n\t// \tvar classString = 'latin-highlighting';\n\t// } else if ($('#cyrillic-button').hasClass('active')) {\n\t// \tvar mode = 2;\n\t// \tvar classString = 'cyrillic-highlighting';\n\t// } else if ($('#tengwar-button').hasClass('active')) {\n\t// \tvar mode = 3;\n\t// \tvar classString = 'tengwar-highlighting';\n\t// } else if ($('#hiragana-button').hasClass('active')) {\n\t// \tvar mode = 4;\n\t// \tvar classString = 'hiragana-highlighting';\n\t// }\n\n\toutput += '<span class=\"highlighting ' + classString + '\"><big>';\n\toutput += markupHighlighting(simplified, mode);\n\toutput += '</big></span>';\n\n\t$element.html(output);\n}\n\nfunction markupHighlighting(simplified, mode) {\n\tvar output = '';\n\tvar beforeOutput = '';\n\tvar afterOutput = ' ';\n\n\tif (simplified.type === 'selbri') {\n\t\tbeforeOutput += '<span class=\"lojban-selbri\">';\n\t\tafterOutput = '</span> ';\n\t} else if (simplified.type === 'modal sumti') {\n\t\tbeforeOutput += '<span class=\"lojban-modal\"><sup>m</sup>';\n\t\tafterOutput = '</span> ';\n\t} else if (simplified.type === 'sumti x') {\n\t\tif (simplified.sumtiPlace > 5) {\n\t\t\tbeforeOutput += '<span class=\"lojban-sumti6\"><sup>' + simplified.sumtiPlace + '</sup>';\n\t\t\tafterOutput = '</span> ';\n\t\t} else {\n\t\t\tbeforeOutput +=\n\t\t\t\t'<span class=\"lojban-sumti' + simplified.sumtiPlace + '\"><sup>' + simplified.sumtiPlace + '</sup>';\n\t\t\tafterOutput = '</span> ';\n\t\t}\n\t} else if (simplified.type === 'prenex') {\n\t\tbeforeOutput += '<span class=\"lojban-prenex\"><sup>p</sup>';\n\t\tafterOutput = '</span> ';\n\t} else if (simplified.type === 'free') {\n\t\tbeforeOutput += '<span class=\"lojban-vocative\"><sup>v</sup>';\n\t\tafterOutput = '</span> ';\n\t}\n\n\tif (simplified.word) {\n\t\toutput += simplified.word;\n\t} else {\n\t\tif (beforeOutput === '') {\n\t\t\tfor (child in simplified.children) {\n\t\t\t\toutput += markupHighlighting(simplified.children[child], mode);\n\t\t\t}\n\t\t} else {\n\t\t\toutput += '<span class=\"lojban-nesting\">' + enumerateTokens(simplified, mode) + '</span>';\n\t\t}\n\t}\n\n\treturn beforeOutput + output + afterOutput;\n}\n\nfunction enumerateTokens(simplified, mode) {\n\tvar output = '';\n\n\tif (simplified.word) {\n\t\toutput += simplified.word;\n\t} else {\n\t\tfor (child in simplified.children) {\n\t\t\tvar textToAdd = enumerateTokens(simplified.children[child], mode);\n\t\t\tif (textToAdd) {\n\t\t\t\toutput += textToAdd + ' ';\n\t\t\t}\n\t\t}\n\t}\n\n\tif (endsWith(output, ' ')) {\n\t\toutput = output.substring(0, output.length - 1);\n\t}\n\n\treturn output;\n}\n\n/**\n * Shows the glossing in the interface.\n */\nfunction showGlossing(text, $element) {\n\tvar output = '<dl class=\"glosser-definition dl-horizontal\">';\n\n\tlet skip_compound = 0;\n\tvar definitions = {};\n\n\tfor (var j = 0; j < text.length; j++) {\n\t\tlet word = text[j];\n\n\t\tif (skip_compound == 0) {\n\t\t\tlet compound = '';\n\n\t\t\tif (word == 'a') {\n\t\t\t\t({ compound, skip_compound } = extractCanonicalCompound(text, j + 1, 1));\n\t\t\t} else if (word == 'e') {\n\t\t\t\t({ compound, skip_compound } = extractCanonicalCompound(text, j + 1, 2));\n\t\t\t} else if (word == 'i') {\n\t\t\t\t({ compound, skip_compound } = extractCanonicalCompound(text, j + 1, 3));\n\t\t\t} else if (word == 'o') {\n\t\t\t\t({ compound, skip_compound } = extractCanonicalCompound(text, j + 1, -1));\n\t\t\t}\n\n\t\t\tword += compound;\n\t\t} else {\n\t\t\tskip_compound--;\n\t\t}\n\n\t\tif (word == 'u') {\n\t\t\t// skip next word which is the borrowing content\n\t\t\tj++;\n\t\t} else if (word != 'o' && words[word]) {\n\t\t\tif (!definitions[word]) {\n\t\t\t\tdefinitions[word] = [\n\t\t\t\t\twords[word].family,\n\t\t\t\t\twords[word].long ? escapeHtml(words[word].long) : words[word].short\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\t}\n\n\tdefinitions = sortMapByKey(definitions);\n\n\tfor (var key in definitions) {\n\t\toutput += '<dt>' + key + '</dt>';\n\t\toutput += '<dd><span class=\"gloss-family\">' + definitions[key][0] + '</span>' + definitions[key][1] + '</dd>';\n\t}\n\n\toutput += '</dl>';\n\n\t$element.html(output);\n}\n\nfunction sortMapByKey(map) {\n\tvar tupleArray = [];\n\tfor (var key in map) tupleArray.push([ key, map[key] ]);\n\ttupleArray.sort(function(a, b) {\n\t\treturn a[0] > b[0];\n\t});\n\tvar sortedMap = {};\n\ttupleArray.forEach(function(el) {\n\t\tsortedMap[el[0]] = el[1];\n\t});\n\treturn sortedMap;\n}\n\nfunction extractCanonicalCompound(text, startIndex, length) {\n\tlet offset = 0;\n\tlet compound = '';\n\n\twhile (length != 0) {\n\t\tlet item = text[startIndex + offset];\n\n\t\t// a terminator\n\t\tif (item == 'a') {\n\t\t\tcompound += ' a';\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (item == 'u') {\n\t\t\tcompound += ' ' + item + text[startIndex + offset + 1];\n\t\t\toffset++;\n\t\t} else {\n\t\t\tcompound += ' ' + item;\n\t\t}\n\n\t\toffset++;\n\t\tlength--;\n\t}\n\n\treturn { compound, offset };\n}\n\n/**\n * Shows the translation in the interface.\n */\nfunction showTranslation(parse, text, $element) {\n\tvar output =\n\t\t'<p class=\"muted\">This translation feature tries to give an approximate translation of the Lojban text into English. However, it does only work for a few sentences as of now. (Try [mi gleki] or something simple like that...)</p>';\n\n\t//var translation = translate(parse);\n\tvar translation = 'Sorry! Translation is switched off at the moment, to prevent crashes in the other parts :-(';\n\toutput += '<center><big>' + translation + '</big></center>';\n\n\t$element.html(output);\n}\n\n// Auxiliary\n\nfunction isString(s) {\n\treturn typeof s === 'string' || s instanceof String;\n}\n\nfunction endsWith(str, suffix) {\n\treturn str.indexOf(suffix, str.length - suffix.length) !== -1;\n}\n\n\n//# sourceURL=webpack://bundle/./webpack/parser.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./webpack/parser.js");
/******/ 	bundle = __webpack_exports__;
/******/ 	
/******/ })()
;